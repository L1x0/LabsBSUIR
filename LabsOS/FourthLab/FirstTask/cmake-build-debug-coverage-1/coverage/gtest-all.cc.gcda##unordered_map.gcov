        -:    0:Source:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.0.sdk/usr/include/c++/v1/unordered_map
        -:    0:Graph:/Users/artemastahov/All_files/styding/LabsBSUIR/LabsOS/FourthLab/FirstTask/cmake-build-debug-coverage-1/googletest/googletest/CMakeFiles/gtest.dir/src/gtest-all.cc.gcno
        -:    0:Data:/Users/artemastahov/All_files/styding/LabsBSUIR/LabsOS/FourthLab/FirstTask/cmake-build-debug-coverage-1/googletest/googletest/CMakeFiles/gtest.dir/src/gtest-all.cc.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// -*- C++ -*-
        -:    2://===----------------------------------------------------------------------===//
        -:    3://
        -:    4:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    5:// See https://llvm.org/LICENSE.txt for license information.
        -:    6:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    7://
        -:    8://===----------------------------------------------------------------------===//
        -:    9:
        -:   10:#ifndef _LIBCPP_UNORDERED_MAP
        -:   11:#define _LIBCPP_UNORDERED_MAP
        -:   12:
        -:   13:/*
        -:   14:
        -:   15:    unordered_map synopsis
        -:   16:
        -:   17:#include <initializer_list>
        -:   18:
        -:   19:namespace std
        -:   20:{
        -:   21:
        -:   22:template <class Key, class T, class Hash = hash<Key>, class Pred = equal_to<Key>,
        -:   23:          class Alloc = allocator<pair<const Key, T>>>
        -:   24:class unordered_map
        -:   25:{
        -:   26:public:
        -:   27:    // types
        -:   28:    typedef Key                                                        key_type;
        -:   29:    typedef T                                                          mapped_type;
        -:   30:    typedef Hash                                                       hasher;
        -:   31:    typedef Pred                                                       key_equal;
        -:   32:    typedef Alloc                                                      allocator_type;
        -:   33:    typedef pair<const key_type, mapped_type>                          value_type;
        -:   34:    typedef value_type&                                                reference;
        -:   35:    typedef const value_type&                                          const_reference;
        -:   36:    typedef typename allocator_traits<allocator_type>::pointer         pointer;
        -:   37:    typedef typename allocator_traits<allocator_type>::const_pointer   const_pointer;
        -:   38:    typedef typename allocator_traits<allocator_type>::size_type       size_type;
        -:   39:    typedef typename allocator_traits<allocator_type>::difference_type difference_type;
        -:   40:
        -:   41:    typedef /unspecified/ iterator;
        -:   42:    typedef /unspecified/ const_iterator;
        -:   43:    typedef /unspecified/ local_iterator;
        -:   44:    typedef /unspecified/ const_local_iterator;
        -:   45:
        -:   46:    typedef unspecified                             node_type;            // C++17
        -:   47:    typedef INSERT_RETURN_TYPE<iterator, node_type> insert_return_type;   // C++17
        -:   48:
        -:   49:    unordered_map()
        -:   50:        noexcept(
        -:   51:            is_nothrow_default_constructible<hasher>::value &&
        -:   52:            is_nothrow_default_constructible<key_equal>::value &&
        -:   53:            is_nothrow_default_constructible<allocator_type>::value);
        -:   54:    explicit unordered_map(size_type n, const hasher& hf = hasher(),
        -:   55:                           const key_equal& eql = key_equal(),
        -:   56:                           const allocator_type& a = allocator_type());
        -:   57:    template <class InputIterator>
        -:   58:        unordered_map(InputIterator f, InputIterator l,
        -:   59:                      size_type n = 0, const hasher& hf = hasher(),
        -:   60:                      const key_equal& eql = key_equal(),
        -:   61:                      const allocator_type& a = allocator_type());
        -:   62:    template<container-compatible-range<value_type> R>
        -:   63:      unordered_map(from_range_t, R&& rg, size_type n = see below,
        -:   64:        const hasher& hf = hasher(), const key_equal& eql = key_equal(),
        -:   65:        const allocator_type& a = allocator_type()); // C++23
        -:   66:
        -:   67:    explicit unordered_map(const allocator_type&);
        -:   68:    unordered_map(const unordered_map&);
        -:   69:    unordered_map(const unordered_map&, const Allocator&);
        -:   70:    unordered_map(unordered_map&&)
        -:   71:        noexcept(
        -:   72:            is_nothrow_move_constructible<hasher>::value &&
        -:   73:            is_nothrow_move_constructible<key_equal>::value &&
        -:   74:            is_nothrow_move_constructible<allocator_type>::value);
        -:   75:    unordered_map(unordered_map&&, const Allocator&);
        -:   76:    unordered_map(initializer_list<value_type>, size_type n = 0,
        -:   77:                  const hasher& hf = hasher(), const key_equal& eql = key_equal(),
        -:   78:                  const allocator_type& a = allocator_type());
        -:   79:    unordered_map(size_type n, const allocator_type& a)
        -:   80:      : unordered_map(n, hasher(), key_equal(), a) {}  // C++14
        -:   81:    unordered_map(size_type n, const hasher& hf, const allocator_type& a)
        -:   82:      : unordered_map(n, hf, key_equal(), a) {}  // C++14
        -:   83:    template <class InputIterator>
        -:   84:      unordered_map(InputIterator f, InputIterator l, size_type n, const allocator_type& a)
        -:   85:      : unordered_map(f, l, n, hasher(), key_equal(), a) {}  // C++14
        -:   86:    template <class InputIterator>
        -:   87:      unordered_map(InputIterator f, InputIterator l, size_type n, const hasher& hf,
        -:   88:        const allocator_type& a)
        -:   89:      : unordered_map(f, l, n, hf, key_equal(), a) {}  // C++14
        -:   90:    template<container-compatible-range<value_type> R>
        -:   91:      unordered_map(from_range_t, R&& rg, size_type n, const allocator_type& a)
        -:   92:        : unordered_map(from_range, std::forward<R>(rg), n, hasher(), key_equal(), a) { } // C++23
        -:   93:    template<container-compatible-range<value_type> R>
        -:   94:      unordered_map(from_range_t, R&& rg, size_type n, const hasher& hf, const allocator_type& a)
        -:   95:        : unordered_map(from_range, std::forward<R>(rg), n, hf, key_equal(), a) { }       // C++23
        -:   96:    unordered_map(initializer_list<value_type> il, size_type n, const allocator_type& a)
        -:   97:      : unordered_map(il, n, hasher(), key_equal(), a) {}  // C++14
        -:   98:    unordered_map(initializer_list<value_type> il, size_type n, const hasher& hf,
        -:   99:      const allocator_type& a)
        -:  100:      : unordered_map(il, n, hf, key_equal(), a) {}  // C++14
        -:  101:    ~unordered_map();
        -:  102:    unordered_map& operator=(const unordered_map&);
        -:  103:    unordered_map& operator=(unordered_map&&)
        -:  104:        noexcept(
        -:  105:            allocator_type::propagate_on_container_move_assignment::value &&
        -:  106:            is_nothrow_move_assignable<allocator_type>::value &&
        -:  107:            is_nothrow_move_assignable<hasher>::value &&
        -:  108:            is_nothrow_move_assignable<key_equal>::value);
        -:  109:    unordered_map& operator=(initializer_list<value_type>);
        -:  110:
        -:  111:    allocator_type get_allocator() const noexcept;
        -:  112:
        -:  113:    bool      empty() const noexcept;
        -:  114:    size_type size() const noexcept;
        -:  115:    size_type max_size() const noexcept;
        -:  116:
        -:  117:    iterator       begin() noexcept;
        -:  118:    iterator       end() noexcept;
        -:  119:    const_iterator begin()  const noexcept;
        -:  120:    const_iterator end()    const noexcept;
        -:  121:    const_iterator cbegin() const noexcept;
        -:  122:    const_iterator cend()   const noexcept;
        -:  123:
        -:  124:    template <class... Args>
        -:  125:        pair<iterator, bool> emplace(Args&&... args);
        -:  126:    template <class... Args>
        -:  127:        iterator emplace_hint(const_iterator position, Args&&... args);
        -:  128:    pair<iterator, bool> insert(const value_type& obj);
        -:  129:    template <class P>
        -:  130:        pair<iterator, bool> insert(P&& obj);
        -:  131:    iterator insert(const_iterator hint, const value_type& obj);
        -:  132:    template <class P>
        -:  133:        iterator insert(const_iterator hint, P&& obj);
        -:  134:    template <class InputIterator>
        -:  135:        void insert(InputIterator first, InputIterator last);
        -:  136:    template<container-compatible-range<value_type> R>
        -:  137:      void insert_range(R&& rg);                                                      // C++23
        -:  138:    void insert(initializer_list<value_type>);
        -:  139:
        -:  140:    node_type extract(const_iterator position);                                       // C++17
        -:  141:    node_type extract(const key_type& x);                                             // C++17
        -:  142:    insert_return_type insert(node_type&& nh);                                        // C++17
        -:  143:    iterator           insert(const_iterator hint, node_type&& nh);                   // C++17
        -:  144:
        -:  145:    template <class... Args>
        -:  146:        pair<iterator, bool> try_emplace(const key_type& k, Args&&... args);          // C++17
        -:  147:    template <class... Args>
        -:  148:        pair<iterator, bool> try_emplace(key_type&& k, Args&&... args);               // C++17
        -:  149:    template <class... Args>
        -:  150:        iterator try_emplace(const_iterator hint, const key_type& k, Args&&... args); // C++17
        -:  151:    template <class... Args>
        -:  152:        iterator try_emplace(const_iterator hint, key_type&& k, Args&&... args);      // C++17
        -:  153:    template <class M>
        -:  154:        pair<iterator, bool> insert_or_assign(const key_type& k, M&& obj);            // C++17
        -:  155:    template <class M>
        -:  156:        pair<iterator, bool> insert_or_assign(key_type&& k, M&& obj);                 // C++17
        -:  157:    template <class M>
        -:  158:        iterator insert_or_assign(const_iterator hint, const key_type& k, M&& obj);   // C++17
        -:  159:    template <class M>
        -:  160:        iterator insert_or_assign(const_iterator hint, key_type&& k, M&& obj);        // C++17
        -:  161:
        -:  162:    iterator erase(const_iterator position);
        -:  163:    iterator erase(iterator position);  // C++14
        -:  164:    size_type erase(const key_type& k);
        -:  165:    iterator erase(const_iterator first, const_iterator last);
        -:  166:    void clear() noexcept;
        -:  167:
        -:  168:    template<class H2, class P2>
        -:  169:      void merge(unordered_map<Key, T, H2, P2, Allocator>& source);         // C++17
        -:  170:    template<class H2, class P2>
        -:  171:      void merge(unordered_map<Key, T, H2, P2, Allocator>&& source);        // C++17
        -:  172:    template<class H2, class P2>
        -:  173:      void merge(unordered_multimap<Key, T, H2, P2, Allocator>& source);    // C++17
        -:  174:    template<class H2, class P2>
        -:  175:      void merge(unordered_multimap<Key, T, H2, P2, Allocator>&& source);   // C++17
        -:  176:
        -:  177:    void swap(unordered_map&)
        -:  178:        noexcept(
        -:  179:            (!allocator_type::propagate_on_container_swap::value ||
        -:  180:             __is_nothrow_swappable<allocator_type>::value) &&
        -:  181:            __is_nothrow_swappable<hasher>::value &&
        -:  182:            __is_nothrow_swappable<key_equal>::value);
        -:  183:
        -:  184:    hasher hash_function() const;
        -:  185:    key_equal key_eq() const;
        -:  186:
        -:  187:    iterator       find(const key_type& k);
        -:  188:    const_iterator find(const key_type& k) const;
        -:  189:    template<typename K>
        -:  190:        iterator find(const K& x);              // C++20
        -:  191:    template<typename K>
        -:  192:        const_iterator find(const K& x) const;  // C++20
        -:  193:    size_type count(const key_type& k) const;
        -:  194:    template<typename K>
        -:  195:        size_type count(const K& k) const; // C++20
        -:  196:    bool contains(const key_type& k) const; // C++20
        -:  197:    template<typename K>
        -:  198:        bool contains(const K& k) const; // C++20
        -:  199:    pair<iterator, iterator>             equal_range(const key_type& k);
        -:  200:    pair<const_iterator, const_iterator> equal_range(const key_type& k) const;
        -:  201:    template<typename K>
        -:  202:        pair<iterator, iterator>             equal_range(const K& k); // C++20
        -:  203:    template<typename K>
        -:  204:        pair<const_iterator, const_iterator> equal_range(const K& k) const; // C++20
        -:  205:
        -:  206:    mapped_type& operator[](const key_type& k);
        -:  207:    mapped_type& operator[](key_type&& k);
        -:  208:
        -:  209:    mapped_type&       at(const key_type& k);
        -:  210:    const mapped_type& at(const key_type& k) const;
        -:  211:
        -:  212:    size_type bucket_count() const noexcept;
        -:  213:    size_type max_bucket_count() const noexcept;
        -:  214:
        -:  215:    size_type bucket_size(size_type n) const;
        -:  216:    size_type bucket(const key_type& k) const;
        -:  217:
        -:  218:    local_iterator       begin(size_type n);
        -:  219:    local_iterator       end(size_type n);
        -:  220:    const_local_iterator begin(size_type n) const;
        -:  221:    const_local_iterator end(size_type n) const;
        -:  222:    const_local_iterator cbegin(size_type n) const;
        -:  223:    const_local_iterator cend(size_type n) const;
        -:  224:
        -:  225:    float load_factor() const noexcept;
        -:  226:    float max_load_factor() const noexcept;
        -:  227:    void max_load_factor(float z);
        -:  228:    void rehash(size_type n);
        -:  229:    void reserve(size_type n);
        -:  230:};
        -:  231:
        -:  232:template<class InputIterator,
        -:  233:    class Hash = hash<iter_key_t<InputIterator>>, class Pred = equal_to<iter_key_t<InputIterator>>,
        -:  234:    class Allocator = allocator<iter_to_alloc_t<InputIterator>>>
        -:  235:unordered_map(InputIterator, InputIterator, typename see below::size_type = see below,
        -:  236:    Hash = Hash(), Pred = Pred(), Allocator = Allocator())
        -:  237:  -> unordered_map<iter_key_t<InputIterator>, iter_value_t<InputIterator>, Hash, Pred,
        -:  238:    Allocator>; // C++17
        -:  239:
        -:  240:template<ranges::input_range R, class Hash = hash<range-key-type<R>>,
        -:  241:         class Pred = equal_to<range-key-type<R>>,
        -:  242:         class Allocator = allocator<range-to-alloc-type<R>>>
        -:  243:  unordered_map(from_range_t, R&&, typename see below::size_type = see below,
        -:  244:                Hash = Hash(), Pred = Pred(), Allocator = Allocator())
        -:  245:    -> unordered_map<range-key-type<R>, range-mapped-type<R>, Hash, Pred, Allocator>; // C++23
        -:  246:
        -:  247:template<class Key, class T, class Hash = hash<Key>,
        -:  248:    class Pred = equal_to<Key>, class Allocator = allocator<pair<const Key, T>>>
        -:  249:unordered_map(initializer_list<pair<const Key, T>>, typename see below::size_type = see below,
        -:  250:    Hash = Hash(), Pred = Pred(), Allocator = Allocator())
        -:  251:  -> unordered_map<Key, T, Hash, Pred, Allocator>; // C++17
        -:  252:
        -:  253:template<class InputIterator, class Allocator>
        -:  254:unordered_map(InputIterator, InputIterator, typename see below::size_type, Allocator)
        -:  255:  -> unordered_map<iter_key_t<InputIterator>, iter_val_t<InputIterator>,
        -:  256:        hash<iter_key_t<InputIterator>>, equal_to<iter_key_t<InputIterator>>, Allocator>; // C++17
        -:  257:
        -:  258:template<class InputIterator, class Allocator>
        -:  259:unordered_map(InputIterator, InputIterator, Allocator)
        -:  260:  -> unordered_map<iter_key_t<InputIterator>, iter_val_t<InputIterator>,
        -:  261:        hash<iter_key_t<InputIterator>>, equal_to<iter_key_t<InputIterator>>, Allocator>; // C++17
        -:  262:
        -:  263:template<class InputIterator, class Hash, class Allocator>
        -:  264:unordered_map(InputIterator, InputIterator, typename see below::size_type, Hash, Allocator)
        -:  265:  -> unordered_map<iter_key_t<InputIterator>, iter_val_t<InputIterator>, Hash,
        -:  266:          equal_to<iter_key_t<InputIterator>>, Allocator>; // C++17
        -:  267:
        -:  268:template<ranges::input_range R, class Allocator>
        -:  269:  unordered_map(from_range_t, R&&, typename see below::size_type, Allocator)
        -:  270:    -> unordered_map<range-key-type<R>, range-mapped-type<R>, hash<range-key-type<R>>,
        -:  271:                      equal_to<range-key-type<R>>, Allocator>;   // C++23
        -:  272:
        -:  273:template<ranges::input_range R, class Allocator>
        -:  274:  unordered_map(from_range_t, R&&, Allocator)
        -:  275:    -> unordered_map<range-key-type<R>, range-mapped-type<R>, hash<range-key-type<R>>,
        -:  276:                      equal_to<range-key-type<R>>, Allocator>;   // C++23
        -:  277:
        -:  278:template<ranges::input_range R, class Hash, class Allocator>
        -:  279:  unordered_map(from_range_t, R&&, typename see below::size_type, Hash, Allocator)
        -:  280:    -> unordered_map<range-key-type<R>, range-mapped-type<R>, Hash,
        -:  281:                      equal_to<range-key-type<R>>, Allocator>;   // C++23
        -:  282:
        -:  283:template<class Key, class T, typename Allocator>
        -:  284:unordered_map(initializer_list<pair<const Key, T>>, typename see below::size_type, Allocator)
        -:  285:  -> unordered_map<Key, T, hash<Key>, equal_to<Key>, Allocator>; // C++17
        -:  286:
        -:  287:template<class Key, class T, typename Allocator>
        -:  288:unordered_map(initializer_list<pair<const Key, T>>, Allocator)
        -:  289:  -> unordered_map<Key, T, hash<Key>, equal_to<Key>, Allocator>; // C++17
        -:  290:
        -:  291:template<class Key, class T, class Hash, class Allocator>
        -:  292:unordered_map(initializer_list<pair<const Key, T>>, typename see below::size_type, Hash, Allocator)
        -:  293:  -> unordered_map<Key, T, Hash, equal_to<Key>, Allocator>; // C++17
        -:  294:
        -:  295:template <class Key, class T, class Hash, class Pred, class Alloc>
        -:  296:    void swap(unordered_map<Key, T, Hash, Pred, Alloc>& x,
        -:  297:              unordered_map<Key, T, Hash, Pred, Alloc>& y)
        -:  298:              noexcept(noexcept(x.swap(y)));
        -:  299:
        -:  300:template <class Key, class T, class Hash, class Pred, class Alloc>
        -:  301:    bool
        -:  302:    operator==(const unordered_map<Key, T, Hash, Pred, Alloc>& x,
        -:  303:               const unordered_map<Key, T, Hash, Pred, Alloc>& y);
        -:  304:
        -:  305:template <class Key, class T, class Hash, class Pred, class Alloc>
        -:  306:    bool
        -:  307:    operator!=(const unordered_map<Key, T, Hash, Pred, Alloc>& x,
        -:  308:               const unordered_map<Key, T, Hash, Pred, Alloc>& y); // Removed in C++20
        -:  309:
        -:  310:template <class Key, class T, class Hash = hash<Key>, class Pred = equal_to<Key>,
        -:  311:          class Alloc = allocator<pair<const Key, T>>>
        -:  312:class unordered_multimap
        -:  313:{
        -:  314:public:
        -:  315:    // types
        -:  316:    typedef Key                                                        key_type;
        -:  317:    typedef T                                                          mapped_type;
        -:  318:    typedef Hash                                                       hasher;
        -:  319:    typedef Pred                                                       key_equal;
        -:  320:    typedef Alloc                                                      allocator_type;
        -:  321:    typedef pair<const key_type, mapped_type>                          value_type;
        -:  322:    typedef value_type&                                                reference;
        -:  323:    typedef const value_type&                                          const_reference;
        -:  324:    typedef typename allocator_traits<allocator_type>::pointer         pointer;
        -:  325:    typedef typename allocator_traits<allocator_type>::const_pointer   const_pointer;
        -:  326:    typedef typename allocator_traits<allocator_type>::size_type       size_type;
        -:  327:    typedef typename allocator_traits<allocator_type>::difference_type difference_type;
        -:  328:
        -:  329:    typedef /unspecified/ iterator;
        -:  330:    typedef /unspecified/ const_iterator;
        -:  331:    typedef /unspecified/ local_iterator;
        -:  332:    typedef /unspecified/ const_local_iterator;
        -:  333:
        -:  334:    typedef unspecified node_type;    // C++17
        -:  335:
        -:  336:    unordered_multimap()
        -:  337:        noexcept(
        -:  338:            is_nothrow_default_constructible<hasher>::value &&
        -:  339:            is_nothrow_default_constructible<key_equal>::value &&
        -:  340:            is_nothrow_default_constructible<allocator_type>::value);
        -:  341:    explicit unordered_multimap(size_type n, const hasher& hf = hasher(),
        -:  342:                           const key_equal& eql = key_equal(),
        -:  343:                           const allocator_type& a = allocator_type());
        -:  344:    template <class InputIterator>
        -:  345:        unordered_multimap(InputIterator f, InputIterator l,
        -:  346:                      size_type n = 0, const hasher& hf = hasher(),
        -:  347:                      const key_equal& eql = key_equal(),
        -:  348:                      const allocator_type& a = allocator_type());
        -:  349:    template<container-compatible-range<value_type> R>
        -:  350:      unordered_multimap(from_range_t, R&& rg, size_type n = see below,
        -:  351:        const hasher& hf = hasher(), const key_equal& eql = key_equal(),
        -:  352:        const allocator_type& a = allocator_type()); // C++23
        -:  353:    explicit unordered_multimap(const allocator_type&);
        -:  354:    unordered_multimap(const unordered_multimap&);
        -:  355:    unordered_multimap(const unordered_multimap&, const Allocator&);
        -:  356:    unordered_multimap(unordered_multimap&&)
        -:  357:        noexcept(
        -:  358:            is_nothrow_move_constructible<hasher>::value &&
        -:  359:            is_nothrow_move_constructible<key_equal>::value &&
        -:  360:            is_nothrow_move_constructible<allocator_type>::value);
        -:  361:    unordered_multimap(unordered_multimap&&, const Allocator&);
        -:  362:    unordered_multimap(initializer_list<value_type>, size_type n = 0,
        -:  363:                  const hasher& hf = hasher(), const key_equal& eql = key_equal(),
        -:  364:                  const allocator_type& a = allocator_type());
        -:  365:    unordered_multimap(size_type n, const allocator_type& a)
        -:  366:      : unordered_multimap(n, hasher(), key_equal(), a) {}  // C++14
        -:  367:    unordered_multimap(size_type n, const hasher& hf, const allocator_type& a)
        -:  368:      : unordered_multimap(n, hf, key_equal(), a) {}  // C++14
        -:  369:    template <class InputIterator>
        -:  370:      unordered_multimap(InputIterator f, InputIterator l, size_type n, const allocator_type& a)
        -:  371:      : unordered_multimap(f, l, n, hasher(), key_equal(), a) {}  // C++14
        -:  372:    template <class InputIterator>
        -:  373:      unordered_multimap(InputIterator f, InputIterator l, size_type n, const hasher& hf,
        -:  374:        const allocator_type& a)
        -:  375:      : unordered_multimap(f, l, n, hf, key_equal(), a) {}  // C++14
        -:  376:    template<container-compatible-range<value_type> R>
        -:  377:      unordered_multimap(from_range_t, R&& rg, size_type n, const allocator_type& a)
        -:  378:        : unordered_multimap(from_range, std::forward<R>(rg), n, hasher(), key_equal(), a) { } // C++23
        -:  379:    template<container-compatible-range<value_type> R>
        -:  380:      unordered_multimap(from_range_t, R&& rg, size_type n, const hasher& hf, const allocator_type& a)
        -:  381:        : unordered_multimap(from_range, std::forward<R>(rg), n, hf, key_equal(), a) { }       // C++23
        -:  382:    unordered_multimap(initializer_list<value_type> il, size_type n, const allocator_type& a)
        -:  383:      : unordered_multimap(il, n, hasher(), key_equal(), a) {}  // C++14
        -:  384:    unordered_multimap(initializer_list<value_type> il, size_type n, const hasher& hf,
        -:  385:      const allocator_type& a)
        -:  386:      : unordered_multimap(il, n, hf, key_equal(), a) {}  // C++14
        -:  387:    ~unordered_multimap();
        -:  388:    unordered_multimap& operator=(const unordered_multimap&);
        -:  389:    unordered_multimap& operator=(unordered_multimap&&)
        -:  390:        noexcept(
        -:  391:            allocator_type::propagate_on_container_move_assignment::value &&
        -:  392:            is_nothrow_move_assignable<allocator_type>::value &&
        -:  393:            is_nothrow_move_assignable<hasher>::value &&
        -:  394:            is_nothrow_move_assignable<key_equal>::value);
        -:  395:    unordered_multimap& operator=(initializer_list<value_type>);
        -:  396:
        -:  397:    allocator_type get_allocator() const noexcept;
        -:  398:
        -:  399:    bool      empty() const noexcept;
        -:  400:    size_type size() const noexcept;
        -:  401:    size_type max_size() const noexcept;
        -:  402:
        -:  403:    iterator       begin() noexcept;
        -:  404:    iterator       end() noexcept;
        -:  405:    const_iterator begin()  const noexcept;
        -:  406:    const_iterator end()    const noexcept;
        -:  407:    const_iterator cbegin() const noexcept;
        -:  408:    const_iterator cend()   const noexcept;
        -:  409:
        -:  410:    template <class... Args>
        -:  411:        iterator emplace(Args&&... args);
        -:  412:    template <class... Args>
        -:  413:        iterator emplace_hint(const_iterator position, Args&&... args);
        -:  414:    iterator insert(const value_type& obj);
        -:  415:    template <class P>
        -:  416:        iterator insert(P&& obj);
        -:  417:    iterator insert(const_iterator hint, const value_type& obj);
        -:  418:    template <class P>
        -:  419:        iterator insert(const_iterator hint, P&& obj);
        -:  420:    template <class InputIterator>
        -:  421:        void insert(InputIterator first, InputIterator last);
        -:  422:    template<container-compatible-range<value_type> R>
        -:  423:      void insert_range(R&& rg);                               // C++23
        -:  424:    void insert(initializer_list<value_type>);
        -:  425:
        -:  426:    node_type extract(const_iterator position);                // C++17
        -:  427:    node_type extract(const key_type& x);                      // C++17
        -:  428:    iterator insert(node_type&& nh);                           // C++17
        -:  429:    iterator insert(const_iterator hint, node_type&& nh);      // C++17
        -:  430:
        -:  431:    iterator erase(const_iterator position);
        -:  432:    iterator erase(iterator position);  // C++14
        -:  433:    size_type erase(const key_type& k);
        -:  434:    iterator erase(const_iterator first, const_iterator last);
        -:  435:    void clear() noexcept;
        -:  436:
        -:  437:    template<class H2, class P2>
        -:  438:      void merge(unordered_multimap<Key, T, H2, P2, Allocator>& source);    // C++17
        -:  439:    template<class H2, class P2>
        -:  440:      void merge(unordered_multimap<Key, T, H2, P2, Allocator>&& source);   // C++17
        -:  441:    template<class H2, class P2>
        -:  442:      void merge(unordered_map<Key, T, H2, P2, Allocator>& source);         // C++17
        -:  443:    template<class H2, class P2>
        -:  444:      void merge(unordered_map<Key, T, H2, P2, Allocator>&& source);        // C++17
        -:  445:
        -:  446:    void swap(unordered_multimap&)
        -:  447:        noexcept(
        -:  448:            (!allocator_type::propagate_on_container_swap::value ||
        -:  449:             __is_nothrow_swappable<allocator_type>::value) &&
        -:  450:            __is_nothrow_swappable<hasher>::value &&
        -:  451:            __is_nothrow_swappable<key_equal>::value);
        -:  452:
        -:  453:    hasher hash_function() const;
        -:  454:    key_equal key_eq() const;
        -:  455:
        -:  456:    iterator       find(const key_type& k);
        -:  457:    const_iterator find(const key_type& k) const;
        -:  458:    template<typename K>
        -:  459:        iterator find(const K& x);              // C++20
        -:  460:    template<typename K>
        -:  461:        const_iterator find(const K& x) const;  // C++20
        -:  462:    size_type count(const key_type& k) const;
        -:  463:    template<typename K>
        -:  464:        size_type count(const K& k) const; // C++20
        -:  465:    bool contains(const key_type& k) const; // C++20
        -:  466:    template<typename K>
        -:  467:        bool contains(const K& k) const; // C++20
        -:  468:    pair<iterator, iterator>             equal_range(const key_type& k);
        -:  469:    pair<const_iterator, const_iterator> equal_range(const key_type& k) const;
        -:  470:    template<typename K>
        -:  471:        pair<iterator, iterator>             equal_range(const K& k); // C++20
        -:  472:    template<typename K>
        -:  473:        pair<const_iterator, const_iterator> equal_range(const K& k) const; // C++20
        -:  474:
        -:  475:    size_type bucket_count() const noexcept;
        -:  476:    size_type max_bucket_count() const noexcept;
        -:  477:
        -:  478:    size_type bucket_size(size_type n) const;
        -:  479:    size_type bucket(const key_type& k) const;
        -:  480:
        -:  481:    local_iterator       begin(size_type n);
        -:  482:    local_iterator       end(size_type n);
        -:  483:    const_local_iterator begin(size_type n) const;
        -:  484:    const_local_iterator end(size_type n) const;
        -:  485:    const_local_iterator cbegin(size_type n) const;
        -:  486:    const_local_iterator cend(size_type n) const;
        -:  487:
        -:  488:    float load_factor() const noexcept;
        -:  489:    float max_load_factor() const noexcept;
        -:  490:    void max_load_factor(float z);
        -:  491:    void rehash(size_type n);
        -:  492:    void reserve(size_type n);
        -:  493:};
        -:  494:
        -:  495:template<class InputIterator,
        -:  496:    class Hash = hash<iter_key_t<InputIterator>>, class Pred = equal_to<iter_key_t<InputIterator>>,
        -:  497:    class Allocator = allocator<iter_to_alloc_t<InputIterator>>>
        -:  498:unordered_multimap(InputIterator, InputIterator, typename see below::size_type = see below,
        -:  499:    Hash = Hash(), Pred = Pred(), Allocator = Allocator())
        -:  500:  -> unordered_multimap<iter_key_t<InputIterator>, iter_value_t<InputIterator>, Hash, Pred,
        -:  501:    Allocator>; // C++17
        -:  502:
        -:  503:template<ranges::input_range R, class Hash = hash<range-key-type<R>>,
        -:  504:         class Pred = equal_to<range-key-type<R>>,
        -:  505:         class Allocator = allocator<range-to-alloc-type<R>>>
        -:  506:  unordered_multimap(from_range_t, R&&, typename see below::size_type = see below,
        -:  507:                Hash = Hash(), Pred = Pred(), Allocator = Allocator())
        -:  508:    -> unordered_multimap<range-key-type<R>, range-mapped-type<R>, Hash, Pred, Allocator>; // C++23
        -:  509:
        -:  510:template<class Key, class T, class Hash = hash<Key>,
        -:  511:    class Pred = equal_to<Key>, class Allocator = allocator<pair<const Key, T>>>
        -:  512:unordered_multimap(initializer_list<pair<const Key, T>>, typename see below::size_type = see below,
        -:  513:    Hash = Hash(), Pred = Pred(), Allocator = Allocator())
        -:  514:  -> unordered_multimap<Key, T, Hash, Pred, Allocator>; // C++17
        -:  515:
        -:  516:template<class InputIterator, class Allocator>
        -:  517:unordered_multimap(InputIterator, InputIterator, typename see below::size_type, Allocator)
        -:  518:  -> unordered_multimap<iter_key_t<InputIterator>, iter_val_t<InputIterator>,
        -:  519:        hash<iter_key_t<InputIterator>>, equal_to<iter_key_t<InputIterator>>, Allocator>; // C++17
        -:  520:
        -:  521:template<class InputIterator, class Allocator>
        -:  522:unordered_multimap(InputIterator, InputIterator, Allocator)
        -:  523:  -> unordered_multimap<iter_key_t<InputIterator>, iter_val_t<InputIterator>,
        -:  524:        hash<iter_key_t<InputIterator>>, equal_to<iter_key_t<InputIterator>>, Allocator>; // C++17
        -:  525:
        -:  526:template<class InputIterator, class Hash, class Allocator>
        -:  527:unordered_multimap(InputIterator, InputIterator, typename see below::size_type, Hash, Allocator)
        -:  528:  -> unordered_multimap<iter_key_t<InputIterator>, iter_val_t<InputIterator>, Hash,
        -:  529:          equal_to<iter_key_t<InputIterator>>, Allocator>; // C++17
        -:  530:
        -:  531:template<ranges::input_range R, class Allocator>
        -:  532:  unordered_multimap(from_range_t, R&&, typename see below::size_type, Allocator)
        -:  533:    -> unordered_multimap<range-key-type<R>, range-mapped-type<R>, hash<range-key-type<R>>,
        -:  534:                      equal_to<range-key-type<R>>, Allocator>;   // C++23
        -:  535:
        -:  536:template<ranges::input_range R, class Allocator>
        -:  537:  unordered_multimap(from_range_t, R&&, Allocator)
        -:  538:    -> unordered_multimap<range-key-type<R>, range-mapped-type<R>, hash<range-key-type<R>>,
        -:  539:                      equal_to<range-key-type<R>>, Allocator>;   // C++23
        -:  540:
        -:  541:template<ranges::input_range R, class Hash, class Allocator>
        -:  542:  unordered_multimap(from_range_t, R&&, typename see below::size_type, Hash, Allocator)
        -:  543:    -> unordered_multimap<range-key-type<R>, range-mapped-type<R>, Hash,
        -:  544:                      equal_to<range-key-type<R>>, Allocator>;   // C++23
        -:  545:
        -:  546:template<class Key, class T, typename Allocator>
        -:  547:unordered_multimap(initializer_list<pair<const Key, T>>, typename see below::size_type, Allocator)
        -:  548:  -> unordered_multimap<Key, T, hash<Key>, equal_to<Key>, Allocator>; // C++17
        -:  549:
        -:  550:template<class Key, class T, typename Allocator>
        -:  551:unordered_multimap(initializer_list<pair<const Key, T>>, Allocator)
        -:  552:  -> unordered_multimap<Key, T, hash<Key>, equal_to<Key>, Allocator>; // C++17
        -:  553:
        -:  554:template<class Key, class T, class Hash, class Allocator>
        -:  555:unordered_multimap(initializer_list<pair<const Key, T>>, typename see below::size_type, Hash,
        -:  556:    Allocator)
        -:  557:  -> unordered_multimap<Key, T, Hash, equal_to<Key>, Allocator>; // C++17
        -:  558:
        -:  559:template <class Key, class T, class Hash, class Pred, class Alloc>
        -:  560:    void swap(unordered_multimap<Key, T, Hash, Pred, Alloc>& x,
        -:  561:              unordered_multimap<Key, T, Hash, Pred, Alloc>& y)
        -:  562:              noexcept(noexcept(x.swap(y)));
        -:  563:
        -:  564:template <class K, class T, class H, class P, class A, class Predicate>
        -:  565:    typename unordered_map<K, T, H, P, A>::size_type
        -:  566:    erase_if(unordered_map<K, T, H, P, A>& c, Predicate pred);       // C++20
        -:  567:
        -:  568:template <class K, class T, class H, class P, class A, class Predicate>
        -:  569:    typename unordered_multimap<K, T, H, P, A>::size_type
        -:  570:    erase_if(unordered_multimap<K, T, H, P, A>& c, Predicate pred);  // C++20
        -:  571:
        -:  572:template <class Key, class T, class Hash, class Pred, class Alloc>
        -:  573:    bool
        -:  574:    operator==(const unordered_multimap<Key, T, Hash, Pred, Alloc>& x,
        -:  575:               const unordered_multimap<Key, T, Hash, Pred, Alloc>& y);
        -:  576:
        -:  577:template <class Key, class T, class Hash, class Pred, class Alloc>
        -:  578:    bool
        -:  579:    operator!=(const unordered_multimap<Key, T, Hash, Pred, Alloc>& x,
        -:  580:               const unordered_multimap<Key, T, Hash, Pred, Alloc>& y); // Removed in C++20
        -:  581:
        -:  582:}  // std
        -:  583:
        -:  584:*/
        -:  585:
        -:  586:#include <__algorithm/is_permutation.h>
        -:  587:#include <__assert> // all public C++ headers provide the assertion handler
        -:  588:#include <__availability>
        -:  589:#include <__config>
        -:  590:#include <__functional/is_transparent.h>
        -:  591:#include <__functional/operations.h>
        -:  592:#include <__hash_table>
        -:  593:#include <__iterator/distance.h>
        -:  594:#include <__iterator/erase_if_container.h>
        -:  595:#include <__iterator/iterator_traits.h>
        -:  596:#include <__iterator/ranges_iterator_traits.h>
        -:  597:#include <__memory/addressof.h>
        -:  598:#include <__memory/allocator.h>
        -:  599:#include <__memory_resource/polymorphic_allocator.h>
        -:  600:#include <__node_handle>
        -:  601:#include <__ranges/concepts.h>
        -:  602:#include <__ranges/container_compatible_range.h>
        -:  603:#include <__ranges/from_range.h>
        -:  604:#include <__type_traits/is_allocator.h>
        -:  605:#include <__type_traits/type_identity.h>
        -:  606:#include <__utility/forward.h>
        -:  607:#include <stdexcept>
        -:  608:#include <tuple>
        -:  609:#include <version>
        -:  610:
        -:  611:// standard-mandated includes
        -:  612:
        -:  613:// [iterator.range]
        -:  614:#include <__iterator/access.h>
        -:  615:#include <__iterator/data.h>
        -:  616:#include <__iterator/empty.h>
        -:  617:#include <__iterator/reverse_access.h>
        -:  618:#include <__iterator/size.h>
        -:  619:
        -:  620:// [unord.map.syn]
        -:  621:#include <compare>
        -:  622:#include <initializer_list>
        -:  623:
        -:  624:#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
        -:  625:#  pragma GCC system_header
        -:  626:#endif
        -:  627:
        -:  628:_LIBCPP_PUSH_MACROS
        -:  629:#include <__undef_macros>
        -:  630:
        -:  631:_LIBCPP_BEGIN_NAMESPACE_STD
        -:  632:
        -:  633:template <class _Key,
        -:  634:          class _Cp,
        -:  635:          class _Hash,
        -:  636:          class _Pred,
        -:  637:          bool = is_empty<_Hash>::value && !__libcpp_is_final<_Hash>::value>
        -:  638:class __unordered_map_hasher : private _Hash {
        -:  639:public:
function _ZNSt3__122__unordered_map_hasherINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS_17__hash_value_typeIS6_mEENS_4hashIS6_EENS_8equal_toIS6_EELb1EEC2B8ne180100Ev called 6 returned 100% blocks executed 100%
function _ZNSt3__122__unordered_map_hasherINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS_17__hash_value_typeIS6_PN7testing9TestSuiteEEENS_4hashIS6_EENS_8equal_toIS6_EELb1EEC2B8ne180100Ev called 6 returned 100% blocks executed 100%
       12:  640:  _LIBCPP_HIDE_FROM_ABI __unordered_map_hasher() _NOEXCEPT_(is_nothrow_default_constructible<_Hash>::value) : _Hash() {}
        6:  640-block  0
        6:  640-block  1
        -:  641:  _LIBCPP_HIDE_FROM_ABI __unordered_map_hasher(const _Hash& __h) _NOEXCEPT_(is_nothrow_copy_constructible<_Hash>::value)
        -:  642:      : _Hash(__h) {}
        -:  643:  _LIBCPP_HIDE_FROM_ABI const _Hash& hash_function() const _NOEXCEPT { return *this; }
        -:  644:  _LIBCPP_HIDE_FROM_ABI size_t operator()(const _Cp& __x) const {
        -:  645:    return static_cast<const _Hash&>(*this)(__x.__get_value().first);
        -:  646:  }
function _ZNKSt3__122__unordered_map_hasherINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS_17__hash_value_typeIS6_PN7testing9TestSuiteEEENS_4hashIS6_EENS_8equal_toIS6_EELb1EEclB8ne180100ERKS6_ called 12 returned 100% blocks executed 100%
       12:  647:  _LIBCPP_HIDE_FROM_ABI size_t operator()(const _Key& __x) const { return static_cast<const _Hash&>(*this)(__x); }
       12:  647-block  0
        -:  648:#if _LIBCPP_STD_VER >= 20
        -:  649:  template <typename _K2>
        -:  650:  _LIBCPP_HIDE_FROM_ABI size_t operator()(const _K2& __x) const {
        -:  651:    return static_cast<const _Hash&>(*this)(__x);
        -:  652:  }
        -:  653:#endif
        -:  654:  _LIBCPP_HIDE_FROM_ABI void swap(__unordered_map_hasher& __y) _NOEXCEPT_(__is_nothrow_swappable<_Hash>::value) {
        -:  655:    using std::swap;
        -:  656:    swap(static_cast<_Hash&>(*this), static_cast<_Hash&>(__y));
        -:  657:  }
        -:  658:};
        -:  659:
        -:  660:template <class _Key, class _Cp, class _Hash, class _Pred>
        -:  661:class __unordered_map_hasher<_Key, _Cp, _Hash, _Pred, false> {
        -:  662:  _Hash __hash_;
        -:  663:
        -:  664:public:
        -:  665:  _LIBCPP_HIDE_FROM_ABI __unordered_map_hasher() _NOEXCEPT_(is_nothrow_default_constructible<_Hash>::value)
        -:  666:      : __hash_() {}
        -:  667:  _LIBCPP_HIDE_FROM_ABI __unordered_map_hasher(const _Hash& __h) _NOEXCEPT_(is_nothrow_copy_constructible<_Hash>::value)
        -:  668:      : __hash_(__h) {}
        -:  669:  _LIBCPP_HIDE_FROM_ABI const _Hash& hash_function() const _NOEXCEPT { return __hash_; }
        -:  670:  _LIBCPP_HIDE_FROM_ABI size_t operator()(const _Cp& __x) const { return __hash_(__x.__get_value().first); }
        -:  671:  _LIBCPP_HIDE_FROM_ABI size_t operator()(const _Key& __x) const { return __hash_(__x); }
        -:  672:#if _LIBCPP_STD_VER >= 20
        -:  673:  template <typename _K2>
        -:  674:  _LIBCPP_HIDE_FROM_ABI size_t operator()(const _K2& __x) const {
        -:  675:    return __hash_(__x);
        -:  676:  }
        -:  677:#endif
        -:  678:  _LIBCPP_HIDE_FROM_ABI void swap(__unordered_map_hasher& __y) _NOEXCEPT_(__is_nothrow_swappable<_Hash>::value) {
        -:  679:    using std::swap;
        -:  680:    swap(__hash_, __y.__hash_);
        -:  681:  }
        -:  682:};
        -:  683:
        -:  684:template <class _Key, class _Cp, class _Hash, class _Pred, bool __b>
        -:  685:inline _LIBCPP_HIDE_FROM_ABI void
        -:  686:swap(__unordered_map_hasher<_Key, _Cp, _Hash, _Pred, __b>& __x,
        -:  687:     __unordered_map_hasher<_Key, _Cp, _Hash, _Pred, __b>& __y) _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y))) {
        -:  688:  __x.swap(__y);
        -:  689:}
        -:  690:
        -:  691:template <class _Key,
        -:  692:          class _Cp,
        -:  693:          class _Pred,
        -:  694:          class _Hash,
        -:  695:          bool = is_empty<_Pred>::value && !__libcpp_is_final<_Pred>::value>
        -:  696:class __unordered_map_equal : private _Pred {
        -:  697:public:
function _ZNSt3__121__unordered_map_equalINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS_17__hash_value_typeIS6_mEENS_8equal_toIS6_EENS_4hashIS6_EELb1EEC2B8ne180100Ev called 6 returned 100% blocks executed 100%
function _ZNSt3__121__unordered_map_equalINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS_17__hash_value_typeIS6_PN7testing9TestSuiteEEENS_8equal_toIS6_EENS_4hashIS6_EELb1EEC2B8ne180100Ev called 6 returned 100% blocks executed 100%
       12:  698:  _LIBCPP_HIDE_FROM_ABI __unordered_map_equal() _NOEXCEPT_(is_nothrow_default_constructible<_Pred>::value) : _Pred() {}
        6:  698-block  0
        6:  698-block  1
        -:  699:  _LIBCPP_HIDE_FROM_ABI __unordered_map_equal(const _Pred& __p) _NOEXCEPT_(is_nothrow_copy_constructible<_Pred>::value)
        -:  700:      : _Pred(__p) {}
        -:  701:  _LIBCPP_HIDE_FROM_ABI const _Pred& key_eq() const _NOEXCEPT { return *this; }
        -:  702:  _LIBCPP_HIDE_FROM_ABI bool operator()(const _Cp& __x, const _Cp& __y) const {
        -:  703:    return static_cast<const _Pred&>(*this)(__x.__get_value().first, __y.__get_value().first);
        -:  704:  }
function _ZNKSt3__121__unordered_map_equalINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS_17__hash_value_typeIS6_PN7testing9TestSuiteEEENS_8equal_toIS6_EENS_4hashIS6_EELb1EEclB8ne180100ERKSB_RKS6_ called 0 returned 0% blocks executed 0%
    #####:  705:  _LIBCPP_HIDE_FROM_ABI bool operator()(const _Cp& __x, const _Key& __y) const {
    #####:  706:    return static_cast<const _Pred&>(*this)(__x.__get_value().first, __y);
    $$$$$:  706-block  0
        -:  707:  }
        -:  708:  _LIBCPP_HIDE_FROM_ABI bool operator()(const _Key& __x, const _Cp& __y) const {
        -:  709:    return static_cast<const _Pred&>(*this)(__x, __y.__get_value().first);
        -:  710:  }
        -:  711:#if _LIBCPP_STD_VER >= 20
        -:  712:  template <typename _K2>
        -:  713:  _LIBCPP_HIDE_FROM_ABI bool operator()(const _Cp& __x, const _K2& __y) const {
        -:  714:    return static_cast<const _Pred&>(*this)(__x.__get_value().first, __y);
        -:  715:  }
        -:  716:  template <typename _K2>
        -:  717:  _LIBCPP_HIDE_FROM_ABI bool operator()(const _K2& __x, const _Cp& __y) const {
        -:  718:    return static_cast<const _Pred&>(*this)(__x, __y.__get_value().first);
        -:  719:  }
        -:  720:  template <typename _K2>
        -:  721:  _LIBCPP_HIDE_FROM_ABI bool operator()(const _Key& __x, const _K2& __y) const {
        -:  722:    return static_cast<const _Pred&>(*this)(__x, __y);
        -:  723:  }
        -:  724:  template <typename _K2>
        -:  725:  _LIBCPP_HIDE_FROM_ABI bool operator()(const _K2& __x, const _Key& __y) const {
        -:  726:    return static_cast<const _Pred&>(*this)(__x, __y);
        -:  727:  }
        -:  728:#endif
        -:  729:  _LIBCPP_HIDE_FROM_ABI void swap(__unordered_map_equal& __y) _NOEXCEPT_(__is_nothrow_swappable<_Pred>::value) {
        -:  730:    using std::swap;
        -:  731:    swap(static_cast<_Pred&>(*this), static_cast<_Pred&>(__y));
        -:  732:  }
        -:  733:};
        -:  734:
        -:  735:template <class _Key, class _Cp, class _Pred, class _Hash>
        -:  736:class __unordered_map_equal<_Key, _Cp, _Pred, _Hash, false> {
        -:  737:  _Pred __pred_;
        -:  738:
        -:  739:public:
        -:  740:  _LIBCPP_HIDE_FROM_ABI __unordered_map_equal() _NOEXCEPT_(is_nothrow_default_constructible<_Pred>::value)
        -:  741:      : __pred_() {}
        -:  742:  _LIBCPP_HIDE_FROM_ABI __unordered_map_equal(const _Pred& __p) _NOEXCEPT_(is_nothrow_copy_constructible<_Pred>::value)
        -:  743:      : __pred_(__p) {}
        -:  744:  _LIBCPP_HIDE_FROM_ABI const _Pred& key_eq() const _NOEXCEPT { return __pred_; }
        -:  745:  _LIBCPP_HIDE_FROM_ABI bool operator()(const _Cp& __x, const _Cp& __y) const {
        -:  746:    return __pred_(__x.__get_value().first, __y.__get_value().first);
        -:  747:  }
        -:  748:  _LIBCPP_HIDE_FROM_ABI bool operator()(const _Cp& __x, const _Key& __y) const {
        -:  749:    return __pred_(__x.__get_value().first, __y);
        -:  750:  }
        -:  751:  _LIBCPP_HIDE_FROM_ABI bool operator()(const _Key& __x, const _Cp& __y) const {
        -:  752:    return __pred_(__x, __y.__get_value().first);
        -:  753:  }
        -:  754:#if _LIBCPP_STD_VER >= 20
        -:  755:  template <typename _K2>
        -:  756:  _LIBCPP_HIDE_FROM_ABI bool operator()(const _Cp& __x, const _K2& __y) const {
        -:  757:    return __pred_(__x.__get_value().first, __y);
        -:  758:  }
        -:  759:  template <typename _K2>
        -:  760:  _LIBCPP_HIDE_FROM_ABI bool operator()(const _K2& __x, const _Cp& __y) const {
        -:  761:    return __pred_(__x, __y.__get_value().first);
        -:  762:  }
        -:  763:  template <typename _K2>
        -:  764:  _LIBCPP_HIDE_FROM_ABI bool operator()(const _Key& __x, const _K2& __y) const {
        -:  765:    return __pred_(__x, __y);
        -:  766:  }
        -:  767:  template <typename _K2>
        -:  768:  _LIBCPP_HIDE_FROM_ABI bool operator()(const _K2& __x, const _Key& __y) const {
        -:  769:    return __pred_(__x, __y);
        -:  770:  }
        -:  771:#endif
        -:  772:  _LIBCPP_HIDE_FROM_ABI void swap(__unordered_map_equal& __y) _NOEXCEPT_(__is_nothrow_swappable<_Pred>::value) {
        -:  773:    using std::swap;
        -:  774:    swap(__pred_, __y.__pred_);
        -:  775:  }
        -:  776:};
        -:  777:
        -:  778:template <class _Key, class _Cp, class _Pred, class _Hash, bool __b>
        -:  779:inline _LIBCPP_HIDE_FROM_ABI void
        -:  780:swap(__unordered_map_equal<_Key, _Cp, _Pred, _Hash, __b>& __x, __unordered_map_equal<_Key, _Cp, _Pred, _Hash, __b>& __y)
        -:  781:    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y))) {
        -:  782:  __x.swap(__y);
        -:  783:}
        -:  784:
        -:  785:template <class _Alloc>
        -:  786:class __hash_map_node_destructor {
        -:  787:  typedef _Alloc allocator_type;
        -:  788:  typedef allocator_traits<allocator_type> __alloc_traits;
        -:  789:
        -:  790:public:
        -:  791:  typedef typename __alloc_traits::pointer pointer;
        -:  792:
        -:  793:private:
        -:  794:  allocator_type& __na_;
        -:  795:
        -:  796:  __hash_map_node_destructor& operator=(const __hash_map_node_destructor&);
        -:  797:
        -:  798:public:
        -:  799:  bool __first_constructed;
        -:  800:  bool __second_constructed;
        -:  801:
        -:  802:  _LIBCPP_HIDE_FROM_ABI explicit __hash_map_node_destructor(allocator_type& __na) _NOEXCEPT
        -:  803:      : __na_(__na),
        -:  804:        __first_constructed(false),
        -:  805:        __second_constructed(false) {}
        -:  806:
        -:  807:#ifndef _LIBCPP_CXX03_LANG
        -:  808:  _LIBCPP_HIDE_FROM_ABI __hash_map_node_destructor(__hash_node_destructor<allocator_type>&& __x) _NOEXCEPT
        -:  809:      : __na_(__x.__na_),
        -:  810:        __first_constructed(__x.__value_constructed),
        -:  811:        __second_constructed(__x.__value_constructed) {
        -:  812:    __x.__value_constructed = false;
        -:  813:  }
        -:  814:#else  // _LIBCPP_CXX03_LANG
        -:  815:  _LIBCPP_HIDE_FROM_ABI __hash_map_node_destructor(const __hash_node_destructor<allocator_type>& __x)
        -:  816:      : __na_(__x.__na_), __first_constructed(__x.__value_constructed), __second_constructed(__x.__value_constructed) {
        -:  817:    const_cast<bool&>(__x.__value_constructed) = false;
        -:  818:  }
        -:  819:#endif // _LIBCPP_CXX03_LANG
        -:  820:
        -:  821:  _LIBCPP_HIDE_FROM_ABI void operator()(pointer __p) _NOEXCEPT {
        -:  822:    if (__second_constructed)
        -:  823:      __alloc_traits::destroy(__na_, std::addressof(__p->__get_value().__get_value().second));
        -:  824:    if (__first_constructed)
        -:  825:      __alloc_traits::destroy(__na_, std::addressof(__p->__get_value().__get_value().first));
        -:  826:    if (__p)
        -:  827:      __alloc_traits::deallocate(__na_, __p, 1);
        -:  828:  }
        -:  829:};
        -:  830:
        -:  831:#ifndef _LIBCPP_CXX03_LANG
        -:  832:template <class _Key, class _Tp>
        -:  833:struct _LIBCPP_STANDALONE_DEBUG __hash_value_type {
        -:  834:  typedef _Key key_type;
        -:  835:  typedef _Tp mapped_type;
        -:  836:  typedef pair<const key_type, mapped_type> value_type;
        -:  837:  typedef pair<key_type&, mapped_type&> __nc_ref_pair_type;
        -:  838:  typedef pair<key_type&&, mapped_type&&> __nc_rref_pair_type;
        -:  839:
        -:  840:private:
        -:  841:  value_type __cc_;
        -:  842:
        -:  843:public:
function _ZNSt3__117__hash_value_typeINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEmE11__get_valueB8ne180100Ev called 0 returned 0% blocks executed 0%
function _ZNSt3__117__hash_value_typeINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEPN7testing9TestSuiteEE11__get_valueB8ne180100Ev called 6 returned 100% blocks executed 100%
        6:  844:  _LIBCPP_HIDE_FROM_ABI value_type& __get_value() {
        -:  845:#  if _LIBCPP_STD_VER >= 17
        -:  846:    return *std::launder(std::addressof(__cc_));
        -:  847:#  else
        6:  848:    return __cc_;
    $$$$$:  848-block  0
        6:  848-block  1
        -:  849:#  endif
        -:  850:  }
        -:  851:
function _ZNKSt3__117__hash_value_typeINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEPN7testing9TestSuiteEE11__get_valueB8ne180100Ev called 0 returned 0% blocks executed 0%
    #####:  852:  _LIBCPP_HIDE_FROM_ABI const value_type& __get_value() const {
        -:  853:#  if _LIBCPP_STD_VER >= 17
        -:  854:    return *std::launder(std::addressof(__cc_));
        -:  855:#  else
    #####:  856:    return __cc_;
    $$$$$:  856-block  0
        -:  857:#  endif
        -:  858:  }
        -:  859:
        -:  860:  _LIBCPP_HIDE_FROM_ABI __nc_ref_pair_type __ref() {
        -:  861:    value_type& __v = __get_value();
        -:  862:    return __nc_ref_pair_type(const_cast<key_type&>(__v.first), __v.second);
        -:  863:  }
        -:  864:
        -:  865:  _LIBCPP_HIDE_FROM_ABI __nc_rref_pair_type __move() {
        -:  866:    value_type& __v = __get_value();
        -:  867:    return __nc_rref_pair_type(std::move(const_cast<key_type&>(__v.first)), std::move(__v.second));
        -:  868:  }
        -:  869:
        -:  870:  _LIBCPP_HIDE_FROM_ABI __hash_value_type& operator=(const __hash_value_type& __v) {
        -:  871:    __ref() = __v.__get_value();
        -:  872:    return *this;
        -:  873:  }
        -:  874:
        -:  875:  _LIBCPP_HIDE_FROM_ABI __hash_value_type& operator=(__hash_value_type&& __v) {
        -:  876:    __ref() = __v.__move();
        -:  877:    return *this;
        -:  878:  }
        -:  879:
        -:  880:  template <class _ValueTp, class = __enable_if_t<__is_same_uncvref<_ValueTp, value_type>::value> >
        -:  881:  _LIBCPP_HIDE_FROM_ABI __hash_value_type& operator=(_ValueTp&& __v) {
        -:  882:    __ref() = std::forward<_ValueTp>(__v);
        -:  883:    return *this;
        -:  884:  }
        -:  885:
        -:  886:private:
        -:  887:  __hash_value_type(const __hash_value_type& __v) = delete;
        -:  888:  __hash_value_type(__hash_value_type&& __v)      = delete;
        -:  889:  template <class... _Args>
        -:  890:  explicit __hash_value_type(_Args&&... __args) = delete;
        -:  891:
        -:  892:  ~__hash_value_type() = delete;
        -:  893:};
        -:  894:
        -:  895:#else
        -:  896:
        -:  897:template <class _Key, class _Tp>
        -:  898:struct __hash_value_type {
        -:  899:  typedef _Key key_type;
        -:  900:  typedef _Tp mapped_type;
        -:  901:  typedef pair<const key_type, mapped_type> value_type;
        -:  902:
        -:  903:private:
        -:  904:  value_type __cc_;
        -:  905:
        -:  906:public:
        -:  907:  _LIBCPP_HIDE_FROM_ABI value_type& __get_value() { return __cc_; }
        -:  908:  _LIBCPP_HIDE_FROM_ABI const value_type& __get_value() const { return __cc_; }
        -:  909:
        -:  910:private:
        -:  911:  ~__hash_value_type();
        -:  912:};
        -:  913:
        -:  914:#endif
        -:  915:
        -:  916:template <class _HashIterator>
        -:  917:class _LIBCPP_TEMPLATE_VIS __hash_map_iterator {
        -:  918:  _HashIterator __i_;
        -:  919:
        -:  920:  typedef __hash_node_types_from_iterator<_HashIterator> _NodeTypes;
        -:  921:
        -:  922:public:
        -:  923:  typedef forward_iterator_tag iterator_category;
        -:  924:  typedef typename _NodeTypes::__map_value_type value_type;
        -:  925:  typedef typename _NodeTypes::difference_type difference_type;
        -:  926:  typedef value_type& reference;
        -:  927:  typedef typename _NodeTypes::__map_value_type_pointer pointer;
        -:  928:
        -:  929:  _LIBCPP_HIDE_FROM_ABI __hash_map_iterator() _NOEXCEPT {}
        -:  930:
function _ZNSt3__119__hash_map_iteratorINS_15__hash_iteratorIPNS_11__hash_nodeINS_17__hash_value_typeINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEPN7testing9TestSuiteEEEPvEEEEEC1B8ne180100ESH_ called 18 returned 100% blocks executed 100%
function _ZNSt3__119__hash_map_iteratorINS_15__hash_iteratorIPNS_11__hash_nodeINS_17__hash_value_typeINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEPN7testing9TestSuiteEEEPvEEEEEC2B8ne180100ESH_ called 18 returned 100% blocks executed 100%
       36:  931:  _LIBCPP_HIDE_FROM_ABI __hash_map_iterator(_HashIterator __i) _NOEXCEPT : __i_(__i) {}
       18:  931-block  0
       18:  931-block  1
        -:  932:
        -:  933:  _LIBCPP_HIDE_FROM_ABI reference operator*() const { return __i_->__get_value(); }
function _ZNKSt3__119__hash_map_iteratorINS_15__hash_iteratorIPNS_11__hash_nodeINS_17__hash_value_typeINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEPN7testing9TestSuiteEEEPvEEEEEptB8ne180100Ev called 0 returned 0% blocks executed 0%
    #####:  934:  _LIBCPP_HIDE_FROM_ABI pointer operator->() const { return pointer_traits<pointer>::pointer_to(__i_->__get_value()); }
    $$$$$:  934-block  0
        -:  935:
        -:  936:  _LIBCPP_HIDE_FROM_ABI __hash_map_iterator& operator++() {
        -:  937:    ++__i_;
        -:  938:    return *this;
        -:  939:  }
        -:  940:  _LIBCPP_HIDE_FROM_ABI __hash_map_iterator operator++(int) {
        -:  941:    __hash_map_iterator __t(*this);
        -:  942:    ++(*this);
        -:  943:    return __t;
        -:  944:  }
        -:  945:
        -:  946:  friend _LIBCPP_HIDE_FROM_ABI bool operator==(const __hash_map_iterator& __x, const __hash_map_iterator& __y) {
        -:  947:    return __x.__i_ == __y.__i_;
        -:  948:  }
        -:  949:#if _LIBCPP_STD_VER <= 17
function _ZNSt3__1neB8ne180100ERKNS_19__hash_map_iteratorINS_15__hash_iteratorIPNS_11__hash_nodeINS_17__hash_value_typeINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEPN7testing9TestSuiteEEEPvEEEEEESK_ called 6 returned 100% blocks executed 100%
        6:  950:  friend _LIBCPP_HIDE_FROM_ABI bool operator!=(const __hash_map_iterator& __x, const __hash_map_iterator& __y) {
        6:  951:    return __x.__i_ != __y.__i_;
        6:  951-block  0
        -:  952:  }
        -:  953:#endif
        -:  954:
        -:  955:  template <class, class, class, class, class>
        -:  956:  friend class _LIBCPP_TEMPLATE_VIS unordered_map;
        -:  957:  template <class, class, class, class, class>
        -:  958:  friend class _LIBCPP_TEMPLATE_VIS unordered_multimap;
        -:  959:  template <class>
        -:  960:  friend class _LIBCPP_TEMPLATE_VIS __hash_const_iterator;
        -:  961:  template <class>
        -:  962:  friend class _LIBCPP_TEMPLATE_VIS __hash_const_local_iterator;
        -:  963:  template <class>
        -:  964:  friend class _LIBCPP_TEMPLATE_VIS __hash_map_const_iterator;
        -:  965:};
        -:  966:
        -:  967:template <class _HashIterator>
        -:  968:class _LIBCPP_TEMPLATE_VIS __hash_map_const_iterator {
        -:  969:  _HashIterator __i_;
        -:  970:
        -:  971:  typedef __hash_node_types_from_iterator<_HashIterator> _NodeTypes;
        -:  972:
        -:  973:public:
        -:  974:  typedef forward_iterator_tag iterator_category;
        -:  975:  typedef typename _NodeTypes::__map_value_type value_type;
        -:  976:  typedef typename _NodeTypes::difference_type difference_type;
        -:  977:  typedef const value_type& reference;
        -:  978:  typedef typename _NodeTypes::__const_map_value_type_pointer pointer;
        -:  979:
        -:  980:  _LIBCPP_HIDE_FROM_ABI __hash_map_const_iterator() _NOEXCEPT {}
        -:  981:
        -:  982:  _LIBCPP_HIDE_FROM_ABI __hash_map_const_iterator(_HashIterator __i) _NOEXCEPT : __i_(__i) {}
        -:  983:  _LIBCPP_HIDE_FROM_ABI
        -:  984:  __hash_map_const_iterator(__hash_map_iterator<typename _HashIterator::__non_const_iterator> __i) _NOEXCEPT
        -:  985:      : __i_(__i.__i_) {}
        -:  986:
        -:  987:  _LIBCPP_HIDE_FROM_ABI reference operator*() const { return __i_->__get_value(); }
        -:  988:  _LIBCPP_HIDE_FROM_ABI pointer operator->() const { return pointer_traits<pointer>::pointer_to(__i_->__get_value()); }
        -:  989:
        -:  990:  _LIBCPP_HIDE_FROM_ABI __hash_map_const_iterator& operator++() {
        -:  991:    ++__i_;
        -:  992:    return *this;
        -:  993:  }
        -:  994:  _LIBCPP_HIDE_FROM_ABI __hash_map_const_iterator operator++(int) {
        -:  995:    __hash_map_const_iterator __t(*this);
        -:  996:    ++(*this);
        -:  997:    return __t;
        -:  998:  }
        -:  999:
        -: 1000:  friend _LIBCPP_HIDE_FROM_ABI bool
        -: 1001:  operator==(const __hash_map_const_iterator& __x, const __hash_map_const_iterator& __y) {
        -: 1002:    return __x.__i_ == __y.__i_;
        -: 1003:  }
        -: 1004:#if _LIBCPP_STD_VER <= 17
        -: 1005:  friend _LIBCPP_HIDE_FROM_ABI bool
        -: 1006:  operator!=(const __hash_map_const_iterator& __x, const __hash_map_const_iterator& __y) {
        -: 1007:    return __x.__i_ != __y.__i_;
        -: 1008:  }
        -: 1009:#endif
        -: 1010:
        -: 1011:  template <class, class, class, class, class>
        -: 1012:  friend class _LIBCPP_TEMPLATE_VIS unordered_map;
        -: 1013:  template <class, class, class, class, class>
        -: 1014:  friend class _LIBCPP_TEMPLATE_VIS unordered_multimap;
        -: 1015:  template <class>
        -: 1016:  friend class _LIBCPP_TEMPLATE_VIS __hash_const_iterator;
        -: 1017:  template <class>
        -: 1018:  friend class _LIBCPP_TEMPLATE_VIS __hash_const_local_iterator;
        -: 1019:};
        -: 1020:
        -: 1021:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
        -: 1022:class unordered_multimap;
        -: 1023:
        -: 1024:template <class _Key,
        -: 1025:          class _Tp,
        -: 1026:          class _Hash  = hash<_Key>,
        -: 1027:          class _Pred  = equal_to<_Key>,
        -: 1028:          class _Alloc = allocator<pair<const _Key, _Tp> > >
        -: 1029:class _LIBCPP_TEMPLATE_VIS unordered_map {
        -: 1030:public:
        -: 1031:  // types
        -: 1032:  typedef _Key key_type;
        -: 1033:  typedef _Tp mapped_type;
        -: 1034:  typedef __type_identity_t<_Hash> hasher;
        -: 1035:  typedef __type_identity_t<_Pred> key_equal;
        -: 1036:  typedef __type_identity_t<_Alloc> allocator_type;
        -: 1037:  typedef pair<const key_type, mapped_type> value_type;
        -: 1038:  typedef value_type& reference;
        -: 1039:  typedef const value_type& const_reference;
        -: 1040:  static_assert((is_same<value_type, typename allocator_type::value_type>::value),
        -: 1041:                "Allocator::value_type must be same type as value_type");
        -: 1042:
        -: 1043:private:
        -: 1044:  typedef __hash_value_type<key_type, mapped_type> __value_type;
        -: 1045:  typedef __unordered_map_hasher<key_type, __value_type, hasher, key_equal> __hasher;
        -: 1046:  typedef __unordered_map_equal<key_type, __value_type, key_equal, hasher> __key_equal;
        -: 1047:  typedef __rebind_alloc<allocator_traits<allocator_type>, __value_type> __allocator_type;
        -: 1048:
        -: 1049:  typedef __hash_table<__value_type, __hasher, __key_equal, __allocator_type> __table;
        -: 1050:
        -: 1051:  __table __table_;
        -: 1052:
        -: 1053:  typedef typename __table::_NodeTypes _NodeTypes;
        -: 1054:  typedef typename __table::__node_pointer __node_pointer;
        -: 1055:  typedef typename __table::__node_const_pointer __node_const_pointer;
        -: 1056:  typedef typename __table::__node_traits __node_traits;
        -: 1057:  typedef typename __table::__node_allocator __node_allocator;
        -: 1058:  typedef typename __table::__node __node;
        -: 1059:  typedef __hash_map_node_destructor<__node_allocator> _Dp;
        -: 1060:  typedef unique_ptr<__node, _Dp> __node_holder;
        -: 1061:  typedef allocator_traits<allocator_type> __alloc_traits;
        -: 1062:
        -: 1063:  static_assert(is_same<allocator_type, __rebind_alloc<__alloc_traits, value_type> >::value,
        -: 1064:                "[allocator.requirements] states that rebinding an allocator to the same type should result in the "
        -: 1065:                "original allocator");
        -: 1066:
        -: 1067:  static_assert((is_same<typename __table::__container_value_type, value_type>::value), "");
        -: 1068:  static_assert((is_same<typename __table::__node_value_type, __value_type>::value), "");
        -: 1069:
        -: 1070:public:
        -: 1071:  typedef typename __alloc_traits::pointer pointer;
        -: 1072:  typedef typename __alloc_traits::const_pointer const_pointer;
        -: 1073:  typedef typename __table::size_type size_type;
        -: 1074:  typedef typename __table::difference_type difference_type;
        -: 1075:
        -: 1076:  typedef __hash_map_iterator<typename __table::iterator> iterator;
        -: 1077:  typedef __hash_map_const_iterator<typename __table::const_iterator> const_iterator;
        -: 1078:  typedef __hash_map_iterator<typename __table::local_iterator> local_iterator;
        -: 1079:  typedef __hash_map_const_iterator<typename __table::const_local_iterator> const_local_iterator;
        -: 1080:
        -: 1081:#if _LIBCPP_STD_VER >= 17
        -: 1082:  typedef __map_node_handle<__node, allocator_type> node_type;
        -: 1083:  typedef __insert_return_type<iterator, node_type> insert_return_type;
        -: 1084:#endif
        -: 1085:
        -: 1086:  template <class _Key2, class _Tp2, class _Hash2, class _Pred2, class _Alloc2>
        -: 1087:  friend class _LIBCPP_TEMPLATE_VIS unordered_map;
        -: 1088:  template <class _Key2, class _Tp2, class _Hash2, class _Pred2, class _Alloc2>
        -: 1089:  friend class _LIBCPP_TEMPLATE_VIS unordered_multimap;
        -: 1090:
function _ZNSt3__113unordered_mapINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEPN7testing9TestSuiteENS_4hashIS6_EENS_8equal_toIS6_EENS4_INS_4pairIKS6_S9_EEEEEC1B8ne180100Ev called 6 returned 100% blocks executed 100%
function _ZNSt3__113unordered_mapINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEmNS_4hashIS6_EENS_8equal_toIS6_EENS4_INS_4pairIKS6_mEEEEEC1B8ne180100Ev called 6 returned 100% blocks executed 100%
function _ZNSt3__113unordered_mapINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEmNS_4hashIS6_EENS_8equal_toIS6_EENS4_INS_4pairIKS6_mEEEEEC2B8ne180100Ev called 6 returned 100% blocks executed 100%
function _ZNSt3__113unordered_mapINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEPN7testing9TestSuiteENS_4hashIS6_EENS_8equal_toIS6_EENS4_INS_4pairIKS6_S9_EEEEEC2B8ne180100Ev called 6 returned 100% blocks executed 100%
       24: 1091:  _LIBCPP_HIDE_FROM_ABI unordered_map() _NOEXCEPT_(is_nothrow_default_constructible<__table>::value) {}
        6: 1091-block  0
        6: 1091-block  1
        6: 1091-block  2
        6: 1091-block  3
        -: 1092:  explicit _LIBCPP_HIDE_FROM_ABI
        -: 1093:  unordered_map(size_type __n, const hasher& __hf = hasher(), const key_equal& __eql = key_equal());
        -: 1094:  _LIBCPP_HIDE_FROM_ABI
        -: 1095:  unordered_map(size_type __n, const hasher& __hf, const key_equal& __eql, const allocator_type& __a);
        -: 1096:  template <class _InputIterator>
        -: 1097:  _LIBCPP_HIDE_FROM_ABI unordered_map(_InputIterator __first, _InputIterator __last);
        -: 1098:  template <class _InputIterator>
        -: 1099:  _LIBCPP_HIDE_FROM_ABI
        -: 1100:  unordered_map(_InputIterator __first,
        -: 1101:                _InputIterator __last,
        -: 1102:                size_type __n,
        -: 1103:                const hasher& __hf     = hasher(),
        -: 1104:                const key_equal& __eql = key_equal());
        -: 1105:  template <class _InputIterator>
        -: 1106:  _LIBCPP_HIDE_FROM_ABI unordered_map(
        -: 1107:      _InputIterator __first,
        -: 1108:      _InputIterator __last,
        -: 1109:      size_type __n,
        -: 1110:      const hasher& __hf,
        -: 1111:      const key_equal& __eql,
        -: 1112:      const allocator_type& __a);
        -: 1113:
        -: 1114:#if _LIBCPP_STD_VER >= 23
        -: 1115:  template <_ContainerCompatibleRange<value_type> _Range>
        -: 1116:  _LIBCPP_HIDE_FROM_ABI unordered_map(
        -: 1117:      from_range_t,
        -: 1118:      _Range&& __range,
        -: 1119:      size_type __n             = /*implementation-defined*/ 0,
        -: 1120:      const hasher& __hf        = hasher(),
        -: 1121:      const key_equal& __eql    = key_equal(),
        -: 1122:      const allocator_type& __a = allocator_type())
        -: 1123:      : __table_(__hf, __eql, typename __table::allocator_type(__a)) {
        -: 1124:    if (__n > 0) {
        -: 1125:      __table_.__rehash_unique(__n);
        -: 1126:    }
        -: 1127:    insert_range(std::forward<_Range>(__range));
        -: 1128:  }
        -: 1129:#endif
        -: 1130:
        -: 1131:  _LIBCPP_HIDE_FROM_ABI explicit unordered_map(const allocator_type& __a);
        -: 1132:  _LIBCPP_HIDE_FROM_ABI unordered_map(const unordered_map& __u);
        -: 1133:  _LIBCPP_HIDE_FROM_ABI unordered_map(const unordered_map& __u, const allocator_type& __a);
        -: 1134:#ifndef _LIBCPP_CXX03_LANG
        -: 1135:  _LIBCPP_HIDE_FROM_ABI unordered_map(unordered_map&& __u) _NOEXCEPT_(is_nothrow_move_constructible<__table>::value);
        -: 1136:  _LIBCPP_HIDE_FROM_ABI unordered_map(unordered_map&& __u, const allocator_type& __a);
        -: 1137:  _LIBCPP_HIDE_FROM_ABI unordered_map(initializer_list<value_type> __il);
        -: 1138:  _LIBCPP_HIDE_FROM_ABI
        -: 1139:  unordered_map(initializer_list<value_type> __il,
        -: 1140:                size_type __n,
        -: 1141:                const hasher& __hf     = hasher(),
        -: 1142:                const key_equal& __eql = key_equal());
        -: 1143:  _LIBCPP_HIDE_FROM_ABI unordered_map(
        -: 1144:      initializer_list<value_type> __il,
        -: 1145:      size_type __n,
        -: 1146:      const hasher& __hf,
        -: 1147:      const key_equal& __eql,
        -: 1148:      const allocator_type& __a);
        -: 1149:#endif // _LIBCPP_CXX03_LANG
        -: 1150:#if _LIBCPP_STD_VER >= 14
        -: 1151:  _LIBCPP_HIDE_FROM_ABI unordered_map(size_type __n, const allocator_type& __a)
        -: 1152:      : unordered_map(__n, hasher(), key_equal(), __a) {}
        -: 1153:  _LIBCPP_HIDE_FROM_ABI unordered_map(size_type __n, const hasher& __hf, const allocator_type& __a)
        -: 1154:      : unordered_map(__n, __hf, key_equal(), __a) {}
        -: 1155:  template <class _InputIterator>
        -: 1156:  _LIBCPP_HIDE_FROM_ABI
        -: 1157:  unordered_map(_InputIterator __first, _InputIterator __last, size_type __n, const allocator_type& __a)
        -: 1158:      : unordered_map(__first, __last, __n, hasher(), key_equal(), __a) {}
        -: 1159:  template <class _InputIterator>
        -: 1160:  _LIBCPP_HIDE_FROM_ABI unordered_map(
        -: 1161:      _InputIterator __first, _InputIterator __last, size_type __n, const hasher& __hf, const allocator_type& __a)
        -: 1162:      : unordered_map(__first, __last, __n, __hf, key_equal(), __a) {}
        -: 1163:
        -: 1164:#  if _LIBCPP_STD_VER >= 23
        -: 1165:  template <_ContainerCompatibleRange<value_type> _Range>
        -: 1166:  _LIBCPP_HIDE_FROM_ABI unordered_map(from_range_t, _Range&& __range, size_type __n, const allocator_type& __a)
        -: 1167:      : unordered_map(from_range, std::forward<_Range>(__range), __n, hasher(), key_equal(), __a) {}
        -: 1168:
        -: 1169:  template <_ContainerCompatibleRange<value_type> _Range>
        -: 1170:  _LIBCPP_HIDE_FROM_ABI
        -: 1171:  unordered_map(from_range_t, _Range&& __range, size_type __n, const hasher& __hf, const allocator_type& __a)
        -: 1172:      : unordered_map(from_range, std::forward<_Range>(__range), __n, __hf, key_equal(), __a) {}
        -: 1173:#  endif
        -: 1174:
        -: 1175:  _LIBCPP_HIDE_FROM_ABI unordered_map(initializer_list<value_type> __il, size_type __n, const allocator_type& __a)
        -: 1176:      : unordered_map(__il, __n, hasher(), key_equal(), __a) {}
        -: 1177:  _LIBCPP_HIDE_FROM_ABI
        -: 1178:  unordered_map(initializer_list<value_type> __il, size_type __n, const hasher& __hf, const allocator_type& __a)
        -: 1179:      : unordered_map(__il, __n, __hf, key_equal(), __a) {}
        -: 1180:#endif
function _ZNSt3__113unordered_mapINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEPN7testing9TestSuiteENS_4hashIS6_EENS_8equal_toIS6_EENS4_INS_4pairIKS6_S9_EEEEED1B8ne180100Ev called 0 returned 0% blocks executed 0%
function _ZNSt3__113unordered_mapINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEmNS_4hashIS6_EENS_8equal_toIS6_EENS4_INS_4pairIKS6_mEEEEED1B8ne180100Ev called 0 returned 0% blocks executed 0%
function _ZNSt3__113unordered_mapINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEmNS_4hashIS6_EENS_8equal_toIS6_EENS4_INS_4pairIKS6_mEEEEED2B8ne180100Ev called 0 returned 0% blocks executed 0%
function _ZNSt3__113unordered_mapINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEPN7testing9TestSuiteENS_4hashIS6_EENS_8equal_toIS6_EENS4_INS_4pairIKS6_S9_EEEEED2B8ne180100Ev called 0 returned 0% blocks executed 0%
    #####: 1181:  _LIBCPP_HIDE_FROM_ABI ~unordered_map() {
        -: 1182:    static_assert(sizeof(std::__diagnose_unordered_container_requirements<_Key, _Hash, _Pred>(0)), "");
    #####: 1183:  }
    $$$$$: 1183-block  0
    $$$$$: 1183-block  1
    $$$$$: 1183-block  2
    $$$$$: 1183-block  3
        -: 1184:
        -: 1185:  _LIBCPP_HIDE_FROM_ABI unordered_map& operator=(const unordered_map& __u) {
        -: 1186:#ifndef _LIBCPP_CXX03_LANG
        -: 1187:    __table_ = __u.__table_;
        -: 1188:#else
        -: 1189:    if (this != std::addressof(__u)) {
        -: 1190:      __table_.clear();
        -: 1191:      __table_.hash_function()   = __u.__table_.hash_function();
        -: 1192:      __table_.key_eq()          = __u.__table_.key_eq();
        -: 1193:      __table_.max_load_factor() = __u.__table_.max_load_factor();
        -: 1194:      __table_.__copy_assign_alloc(__u.__table_);
        -: 1195:      insert(__u.begin(), __u.end());
        -: 1196:    }
        -: 1197:#endif
        -: 1198:    return *this;
        -: 1199:  }
        -: 1200:#ifndef _LIBCPP_CXX03_LANG
        -: 1201:  _LIBCPP_HIDE_FROM_ABI unordered_map& operator=(unordered_map&& __u)
        -: 1202:      _NOEXCEPT_(is_nothrow_move_assignable<__table>::value);
        -: 1203:  _LIBCPP_HIDE_FROM_ABI unordered_map& operator=(initializer_list<value_type> __il);
        -: 1204:#endif // _LIBCPP_CXX03_LANG
        -: 1205:
        -: 1206:  _LIBCPP_HIDE_FROM_ABI allocator_type get_allocator() const _NOEXCEPT {
        -: 1207:    return allocator_type(__table_.__node_alloc());
        -: 1208:  }
        -: 1209:
        -: 1210:  _LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_HIDE_FROM_ABI bool empty() const _NOEXCEPT { return __table_.size() == 0; }
        -: 1211:  _LIBCPP_HIDE_FROM_ABI size_type size() const _NOEXCEPT { return __table_.size(); }
        -: 1212:  _LIBCPP_HIDE_FROM_ABI size_type max_size() const _NOEXCEPT { return __table_.max_size(); }
        -: 1213:
        -: 1214:  _LIBCPP_HIDE_FROM_ABI iterator begin() _NOEXCEPT { return __table_.begin(); }
function _ZNSt3__113unordered_mapINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEPN7testing9TestSuiteENS_4hashIS6_EENS_8equal_toIS6_EENS4_INS_4pairIKS6_S9_EEEEE3endB8ne180100Ev called 6 returned 100% blocks executed 100%
        6: 1215:  _LIBCPP_HIDE_FROM_ABI iterator end() _NOEXCEPT { return __table_.end(); }
        6: 1215-block  0
        -: 1216:  _LIBCPP_HIDE_FROM_ABI const_iterator begin() const _NOEXCEPT { return __table_.begin(); }
        -: 1217:  _LIBCPP_HIDE_FROM_ABI const_iterator end() const _NOEXCEPT { return __table_.end(); }
        -: 1218:  _LIBCPP_HIDE_FROM_ABI const_iterator cbegin() const _NOEXCEPT { return __table_.begin(); }
        -: 1219:  _LIBCPP_HIDE_FROM_ABI const_iterator cend() const _NOEXCEPT { return __table_.end(); }
        -: 1220:
        -: 1221:  _LIBCPP_HIDE_FROM_ABI pair<iterator, bool> insert(const value_type& __x) { return __table_.__insert_unique(__x); }
        -: 1222:
        -: 1223:  _LIBCPP_HIDE_FROM_ABI iterator insert(const_iterator, const value_type& __x) { return insert(__x).first; }
        -: 1224:
        -: 1225:  template <class _InputIterator>
        -: 1226:  _LIBCPP_HIDE_FROM_ABI void insert(_InputIterator __first, _InputIterator __last);
        -: 1227:
        -: 1228:#if _LIBCPP_STD_VER >= 23
        -: 1229:  template <_ContainerCompatibleRange<value_type> _Range>
        -: 1230:  _LIBCPP_HIDE_FROM_ABI void insert_range(_Range&& __range) {
        -: 1231:    for (auto&& __element : __range) {
        -: 1232:      __table_.__insert_unique(std::forward<decltype(__element)>(__element));
        -: 1233:    }
        -: 1234:  }
        -: 1235:#endif
        -: 1236:
        -: 1237:#ifndef _LIBCPP_CXX03_LANG
        -: 1238:  _LIBCPP_HIDE_FROM_ABI void insert(initializer_list<value_type> __il) { insert(__il.begin(), __il.end()); }
        -: 1239:
        -: 1240:  _LIBCPP_HIDE_FROM_ABI pair<iterator, bool> insert(value_type&& __x) {
        -: 1241:    return __table_.__insert_unique(std::move(__x));
        -: 1242:  }
        -: 1243:
        -: 1244:  _LIBCPP_HIDE_FROM_ABI iterator insert(const_iterator, value_type&& __x) {
        -: 1245:    return __table_.__insert_unique(std::move(__x)).first;
        -: 1246:  }
        -: 1247:
        -: 1248:  template <class _Pp, class = __enable_if_t<is_constructible<value_type, _Pp>::value> >
        -: 1249:  _LIBCPP_HIDE_FROM_ABI pair<iterator, bool> insert(_Pp&& __x) {
        -: 1250:    return __table_.__insert_unique(std::forward<_Pp>(__x));
        -: 1251:  }
        -: 1252:
        -: 1253:  template <class _Pp, class = __enable_if_t<is_constructible<value_type, _Pp>::value> >
        -: 1254:  _LIBCPP_HIDE_FROM_ABI iterator insert(const_iterator, _Pp&& __x) {
        -: 1255:    return insert(std::forward<_Pp>(__x)).first;
        -: 1256:  }
        -: 1257:
        -: 1258:  template <class... _Args>
function _ZNSt3__113unordered_mapINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEPN7testing9TestSuiteENS_4hashIS6_EENS_8equal_toIS6_EENS4_INS_4pairIKS6_S9_EEEEE7emplaceB8ne180100IJRSF_RKS9_EEENSE_INS_19__hash_map_iteratorINS_15__hash_iteratorIPNS_11__hash_nodeINS_17__hash_value_typeIS6_S9_EEPvEEEEEEbEEDpOT_ called 6 returned 100% blocks executed 100%
        6: 1259:  _LIBCPP_HIDE_FROM_ABI pair<iterator, bool> emplace(_Args&&... __args) {
        6: 1260:    return __table_.__emplace_unique(std::forward<_Args>(__args)...);
        6: 1260-block  0
        -: 1261:  }
        -: 1262:
        -: 1263:  template <class... _Args>
        -: 1264:  _LIBCPP_HIDE_FROM_ABI iterator emplace_hint(const_iterator, _Args&&... __args) {
        -: 1265:    return __table_.__emplace_unique(std::forward<_Args>(__args)...).first;
        -: 1266:  }
        -: 1267:
        -: 1268:#endif // _LIBCPP_CXX03_LANG
        -: 1269:
        -: 1270:#if _LIBCPP_STD_VER >= 17
        -: 1271:  template <class... _Args>
        -: 1272:  _LIBCPP_HIDE_FROM_ABI pair<iterator, bool> try_emplace(const key_type& __k, _Args&&... __args) {
        -: 1273:    return __table_.__emplace_unique_key_args(
        -: 1274:        __k, piecewise_construct, std::forward_as_tuple(__k), std::forward_as_tuple(std::forward<_Args>(__args)...));
        -: 1275:  }
        -: 1276:
        -: 1277:  template <class... _Args>
        -: 1278:  _LIBCPP_HIDE_FROM_ABI pair<iterator, bool> try_emplace(key_type&& __k, _Args&&... __args) {
        -: 1279:    return __table_.__emplace_unique_key_args(
        -: 1280:        __k,
        -: 1281:        piecewise_construct,
        -: 1282:        std::forward_as_tuple(std::move(__k)),
        -: 1283:        std::forward_as_tuple(std::forward<_Args>(__args)...));
        -: 1284:  }
        -: 1285:
        -: 1286:  template <class... _Args>
        -: 1287:  _LIBCPP_HIDE_FROM_ABI iterator try_emplace(const_iterator, const key_type& __k, _Args&&... __args) {
        -: 1288:    return try_emplace(__k, std::forward<_Args>(__args)...).first;
        -: 1289:  }
        -: 1290:
        -: 1291:  template <class... _Args>
        -: 1292:  _LIBCPP_HIDE_FROM_ABI iterator try_emplace(const_iterator, key_type&& __k, _Args&&... __args) {
        -: 1293:    return try_emplace(std::move(__k), std::forward<_Args>(__args)...).first;
        -: 1294:  }
        -: 1295:
        -: 1296:  template <class _Vp>
        -: 1297:  _LIBCPP_HIDE_FROM_ABI pair<iterator, bool> insert_or_assign(const key_type& __k, _Vp&& __v) {
        -: 1298:    pair<iterator, bool> __res = __table_.__emplace_unique_key_args(__k, __k, std::forward<_Vp>(__v));
        -: 1299:    if (!__res.second) {
        -: 1300:      __res.first->second = std::forward<_Vp>(__v);
        -: 1301:    }
        -: 1302:    return __res;
        -: 1303:  }
        -: 1304:
        -: 1305:  template <class _Vp>
        -: 1306:  _LIBCPP_HIDE_FROM_ABI pair<iterator, bool> insert_or_assign(key_type&& __k, _Vp&& __v) {
        -: 1307:    pair<iterator, bool> __res = __table_.__emplace_unique_key_args(__k, std::move(__k), std::forward<_Vp>(__v));
        -: 1308:    if (!__res.second) {
        -: 1309:      __res.first->second = std::forward<_Vp>(__v);
        -: 1310:    }
        -: 1311:    return __res;
        -: 1312:  }
        -: 1313:
        -: 1314:  template <class _Vp>
        -: 1315:  _LIBCPP_HIDE_FROM_ABI iterator insert_or_assign(const_iterator, const key_type& __k, _Vp&& __v) {
        -: 1316:    return insert_or_assign(__k, std::forward<_Vp>(__v)).first;
        -: 1317:  }
        -: 1318:
        -: 1319:  template <class _Vp>
        -: 1320:  _LIBCPP_HIDE_FROM_ABI iterator insert_or_assign(const_iterator, key_type&& __k, _Vp&& __v) {
        -: 1321:    return insert_or_assign(std::move(__k), std::forward<_Vp>(__v)).first;
        -: 1322:  }
        -: 1323:#endif // _LIBCPP_STD_VER >= 17
        -: 1324:
        -: 1325:  _LIBCPP_HIDE_FROM_ABI iterator erase(const_iterator __p) { return __table_.erase(__p.__i_); }
        -: 1326:  _LIBCPP_HIDE_FROM_ABI iterator erase(iterator __p) { return __table_.erase(__p.__i_); }
        -: 1327:  _LIBCPP_HIDE_FROM_ABI size_type erase(const key_type& __k) { return __table_.__erase_unique(__k); }
        -: 1328:  _LIBCPP_HIDE_FROM_ABI iterator erase(const_iterator __first, const_iterator __last) {
        -: 1329:    return __table_.erase(__first.__i_, __last.__i_);
        -: 1330:  }
        -: 1331:  _LIBCPP_HIDE_FROM_ABI void clear() _NOEXCEPT { __table_.clear(); }
        -: 1332:
        -: 1333:#if _LIBCPP_STD_VER >= 17
        -: 1334:  _LIBCPP_HIDE_FROM_ABI insert_return_type insert(node_type&& __nh) {
        -: 1335:    _LIBCPP_ASSERT_COMPATIBLE_ALLOCATOR(__nh.empty() || __nh.get_allocator() == get_allocator(),
        -: 1336:                                        "node_type with incompatible allocator passed to unordered_map::insert()");
        -: 1337:    return __table_.template __node_handle_insert_unique< node_type, insert_return_type>(std::move(__nh));
        -: 1338:  }
        -: 1339:  _LIBCPP_HIDE_FROM_ABI iterator insert(const_iterator __hint, node_type&& __nh) {
        -: 1340:    _LIBCPP_ASSERT_COMPATIBLE_ALLOCATOR(__nh.empty() || __nh.get_allocator() == get_allocator(),
        -: 1341:                                        "node_type with incompatible allocator passed to unordered_map::insert()");
        -: 1342:    return __table_.template __node_handle_insert_unique<node_type>(__hint.__i_, std::move(__nh));
        -: 1343:  }
        -: 1344:  _LIBCPP_HIDE_FROM_ABI node_type extract(key_type const& __key) {
        -: 1345:    return __table_.template __node_handle_extract<node_type>(__key);
        -: 1346:  }
        -: 1347:  _LIBCPP_HIDE_FROM_ABI node_type extract(const_iterator __it) {
        -: 1348:    return __table_.template __node_handle_extract<node_type>(__it.__i_);
        -: 1349:  }
        -: 1350:
        -: 1351:  template <class _H2, class _P2>
        -: 1352:  _LIBCPP_HIDE_FROM_ABI void merge(unordered_map<key_type, mapped_type, _H2, _P2, allocator_type>& __source) {
        -: 1353:    _LIBCPP_ASSERT_COMPATIBLE_ALLOCATOR(
        -: 1354:        __source.get_allocator() == get_allocator(), "merging container with incompatible allocator");
        -: 1355:    return __table_.__node_handle_merge_unique(__source.__table_);
        -: 1356:  }
        -: 1357:  template <class _H2, class _P2>
        -: 1358:  _LIBCPP_HIDE_FROM_ABI void merge(unordered_map<key_type, mapped_type, _H2, _P2, allocator_type>&& __source) {
        -: 1359:    _LIBCPP_ASSERT_COMPATIBLE_ALLOCATOR(
        -: 1360:        __source.get_allocator() == get_allocator(), "merging container with incompatible allocator");
        -: 1361:    return __table_.__node_handle_merge_unique(__source.__table_);
        -: 1362:  }
        -: 1363:  template <class _H2, class _P2>
        -: 1364:  _LIBCPP_HIDE_FROM_ABI void merge(unordered_multimap<key_type, mapped_type, _H2, _P2, allocator_type>& __source) {
        -: 1365:    _LIBCPP_ASSERT_COMPATIBLE_ALLOCATOR(
        -: 1366:        __source.get_allocator() == get_allocator(), "merging container with incompatible allocator");
        -: 1367:    return __table_.__node_handle_merge_unique(__source.__table_);
        -: 1368:  }
        -: 1369:  template <class _H2, class _P2>
        -: 1370:  _LIBCPP_HIDE_FROM_ABI void merge(unordered_multimap<key_type, mapped_type, _H2, _P2, allocator_type>&& __source) {
        -: 1371:    _LIBCPP_ASSERT_COMPATIBLE_ALLOCATOR(
        -: 1372:        __source.get_allocator() == get_allocator(), "merging container with incompatible allocator");
        -: 1373:    return __table_.__node_handle_merge_unique(__source.__table_);
        -: 1374:  }
        -: 1375:#endif
        -: 1376:
        -: 1377:  _LIBCPP_HIDE_FROM_ABI void swap(unordered_map& __u) _NOEXCEPT_(__is_nothrow_swappable<__table>::value) {
        -: 1378:    __table_.swap(__u.__table_);
        -: 1379:  }
        -: 1380:
        -: 1381:  _LIBCPP_HIDE_FROM_ABI hasher hash_function() const { return __table_.hash_function().hash_function(); }
        -: 1382:  _LIBCPP_HIDE_FROM_ABI key_equal key_eq() const { return __table_.key_eq().key_eq(); }
        -: 1383:
function _ZNSt3__113unordered_mapINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEPN7testing9TestSuiteENS_4hashIS6_EENS_8equal_toIS6_EENS4_INS_4pairIKS6_S9_EEEEE4findB8ne180100ERSF_ called 6 returned 100% blocks executed 100%
        6: 1384:  _LIBCPP_HIDE_FROM_ABI iterator find(const key_type& __k) { return __table_.find(__k); }
        6: 1384-block  0
        -: 1385:  _LIBCPP_HIDE_FROM_ABI const_iterator find(const key_type& __k) const { return __table_.find(__k); }
        -: 1386:#if _LIBCPP_STD_VER >= 20
        -: 1387:  template <class _K2,
        -: 1388:            enable_if_t<__is_transparent<hasher, _K2>::value && __is_transparent<key_equal, _K2>::value>* = nullptr>
        -: 1389:  _LIBCPP_HIDE_FROM_ABI iterator find(const _K2& __k) {
        -: 1390:    return __table_.find(__k);
        -: 1391:  }
        -: 1392:  template <class _K2,
        -: 1393:            enable_if_t<__is_transparent<hasher, _K2>::value && __is_transparent<key_equal, _K2>::value>* = nullptr>
        -: 1394:  _LIBCPP_HIDE_FROM_ABI const_iterator find(const _K2& __k) const {
        -: 1395:    return __table_.find(__k);
        -: 1396:  }
        -: 1397:#endif // _LIBCPP_STD_VER >= 20
        -: 1398:
        -: 1399:  _LIBCPP_HIDE_FROM_ABI size_type count(const key_type& __k) const { return __table_.__count_unique(__k); }
        -: 1400:#if _LIBCPP_STD_VER >= 20
        -: 1401:  template <class _K2,
        -: 1402:            enable_if_t<__is_transparent<hasher, _K2>::value && __is_transparent<key_equal, _K2>::value>* = nullptr>
        -: 1403:  _LIBCPP_HIDE_FROM_ABI size_type count(const _K2& __k) const {
        -: 1404:    return __table_.__count_unique(__k);
        -: 1405:  }
        -: 1406:#endif // _LIBCPP_STD_VER >= 20
        -: 1407:
        -: 1408:#if _LIBCPP_STD_VER >= 20
        -: 1409:  _LIBCPP_HIDE_FROM_ABI bool contains(const key_type& __k) const { return find(__k) != end(); }
        -: 1410:
        -: 1411:  template <class _K2,
        -: 1412:            enable_if_t<__is_transparent<hasher, _K2>::value && __is_transparent<key_equal, _K2>::value>* = nullptr>
        -: 1413:  _LIBCPP_HIDE_FROM_ABI bool contains(const _K2& __k) const {
        -: 1414:    return find(__k) != end();
        -: 1415:  }
        -: 1416:#endif // _LIBCPP_STD_VER >= 20
        -: 1417:
        -: 1418:  _LIBCPP_HIDE_FROM_ABI pair<iterator, iterator> equal_range(const key_type& __k) {
        -: 1419:    return __table_.__equal_range_unique(__k);
        -: 1420:  }
        -: 1421:  _LIBCPP_HIDE_FROM_ABI pair<const_iterator, const_iterator> equal_range(const key_type& __k) const {
        -: 1422:    return __table_.__equal_range_unique(__k);
        -: 1423:  }
        -: 1424:#if _LIBCPP_STD_VER >= 20
        -: 1425:  template <class _K2,
        -: 1426:            enable_if_t<__is_transparent<hasher, _K2>::value && __is_transparent<key_equal, _K2>::value>* = nullptr>
        -: 1427:  _LIBCPP_HIDE_FROM_ABI pair<iterator, iterator> equal_range(const _K2& __k) {
        -: 1428:    return __table_.__equal_range_unique(__k);
        -: 1429:  }
        -: 1430:  template <class _K2,
        -: 1431:            enable_if_t<__is_transparent<hasher, _K2>::value && __is_transparent<key_equal, _K2>::value>* = nullptr>
        -: 1432:  _LIBCPP_HIDE_FROM_ABI pair<const_iterator, const_iterator> equal_range(const _K2& __k) const {
        -: 1433:    return __table_.__equal_range_unique(__k);
        -: 1434:  }
        -: 1435:#endif // _LIBCPP_STD_VER >= 20
        -: 1436:
        -: 1437:  _LIBCPP_HIDE_FROM_ABI mapped_type& operator[](const key_type& __k);
        -: 1438:#ifndef _LIBCPP_CXX03_LANG
        -: 1439:  _LIBCPP_HIDE_FROM_ABI mapped_type& operator[](key_type&& __k);
        -: 1440:#endif
        -: 1441:
        -: 1442:  _LIBCPP_HIDE_FROM_ABI mapped_type& at(const key_type& __k);
        -: 1443:  _LIBCPP_HIDE_FROM_ABI const mapped_type& at(const key_type& __k) const;
        -: 1444:
        -: 1445:  _LIBCPP_HIDE_FROM_ABI size_type bucket_count() const _NOEXCEPT { return __table_.bucket_count(); }
        -: 1446:  _LIBCPP_HIDE_FROM_ABI size_type max_bucket_count() const _NOEXCEPT { return __table_.max_bucket_count(); }
        -: 1447:
        -: 1448:  _LIBCPP_HIDE_FROM_ABI size_type bucket_size(size_type __n) const { return __table_.bucket_size(__n); }
        -: 1449:  _LIBCPP_HIDE_FROM_ABI size_type bucket(const key_type& __k) const { return __table_.bucket(__k); }
        -: 1450:
        -: 1451:  _LIBCPP_HIDE_FROM_ABI local_iterator begin(size_type __n) { return __table_.begin(__n); }
        -: 1452:  _LIBCPP_HIDE_FROM_ABI local_iterator end(size_type __n) { return __table_.end(__n); }
        -: 1453:  _LIBCPP_HIDE_FROM_ABI const_local_iterator begin(size_type __n) const { return __table_.cbegin(__n); }
        -: 1454:  _LIBCPP_HIDE_FROM_ABI const_local_iterator end(size_type __n) const { return __table_.cend(__n); }
        -: 1455:  _LIBCPP_HIDE_FROM_ABI const_local_iterator cbegin(size_type __n) const { return __table_.cbegin(__n); }
        -: 1456:  _LIBCPP_HIDE_FROM_ABI const_local_iterator cend(size_type __n) const { return __table_.cend(__n); }
        -: 1457:
        -: 1458:  _LIBCPP_HIDE_FROM_ABI float load_factor() const _NOEXCEPT { return __table_.load_factor(); }
        -: 1459:  _LIBCPP_HIDE_FROM_ABI float max_load_factor() const _NOEXCEPT { return __table_.max_load_factor(); }
        -: 1460:  _LIBCPP_HIDE_FROM_ABI void max_load_factor(float __mlf) { __table_.max_load_factor(__mlf); }
        -: 1461:  _LIBCPP_HIDE_FROM_ABI void rehash(size_type __n) { __table_.__rehash_unique(__n); }
        -: 1462:  _LIBCPP_HIDE_FROM_ABI void reserve(size_type __n) { __table_.__reserve_unique(__n); }
        -: 1463:
        -: 1464:private:
        -: 1465:#ifdef _LIBCPP_CXX03_LANG
        -: 1466:  _LIBCPP_HIDE_FROM_ABI __node_holder __construct_node_with_key(const key_type& __k);
        -: 1467:#endif
        -: 1468:};
        -: 1469:
        -: 1470:#if _LIBCPP_STD_VER >= 17
        -: 1471:template <class _InputIterator,
        -: 1472:          class _Hash      = hash<__iter_key_type<_InputIterator>>,
        -: 1473:          class _Pred      = equal_to<__iter_key_type<_InputIterator>>,
        -: 1474:          class _Allocator = allocator<__iter_to_alloc_type<_InputIterator>>,
        -: 1475:          class            = enable_if_t<__has_input_iterator_category<_InputIterator>::value>,
        -: 1476:          class            = enable_if_t<!__is_allocator<_Hash>::value>,
        -: 1477:          class            = enable_if_t<!is_integral<_Hash>::value>,
        -: 1478:          class            = enable_if_t<!__is_allocator<_Pred>::value>,
        -: 1479:          class            = enable_if_t<__is_allocator<_Allocator>::value>>
        -: 1480:unordered_map(_InputIterator,
        -: 1481:              _InputIterator,
        -: 1482:              typename allocator_traits<_Allocator>::size_type = 0,
        -: 1483:              _Hash                                            = _Hash(),
        -: 1484:              _Pred                                            = _Pred(),
        -: 1485:              _Allocator                                       = _Allocator())
        -: 1486:    -> unordered_map<__iter_key_type<_InputIterator>, __iter_mapped_type<_InputIterator>, _Hash, _Pred, _Allocator>;
        -: 1487:
        -: 1488:#  if _LIBCPP_STD_VER >= 23
        -: 1489:template <ranges::input_range _Range,
        -: 1490:          class _Hash      = hash<__range_key_type<_Range>>,
        -: 1491:          class _Pred      = equal_to<__range_key_type<_Range>>,
        -: 1492:          class _Allocator = allocator<__range_to_alloc_type<_Range>>,
        -: 1493:          class            = enable_if_t<!__is_allocator<_Hash>::value>,
        -: 1494:          class            = enable_if_t<!is_integral<_Hash>::value>,
        -: 1495:          class            = enable_if_t<!__is_allocator<_Pred>::value>,
        -: 1496:          class            = enable_if_t<__is_allocator<_Allocator>::value>>
        -: 1497:unordered_map(from_range_t,
        -: 1498:              _Range&&,
        -: 1499:              typename allocator_traits<_Allocator>::size_type = 0,
        -: 1500:              _Hash                                            = _Hash(),
        -: 1501:              _Pred                                            = _Pred(),
        -: 1502:              _Allocator                                       = _Allocator())
        -: 1503:    -> unordered_map<__range_key_type<_Range>, __range_mapped_type<_Range>, _Hash, _Pred, _Allocator>; // C++23
        -: 1504:#  endif
        -: 1505:
        -: 1506:template <class _Key,
        -: 1507:          class _Tp,
        -: 1508:          class _Hash      = hash<remove_const_t<_Key>>,
        -: 1509:          class _Pred      = equal_to<remove_const_t<_Key>>,
        -: 1510:          class _Allocator = allocator<pair<const _Key, _Tp>>,
        -: 1511:          class            = enable_if_t<!__is_allocator<_Hash>::value>,
        -: 1512:          class            = enable_if_t<!is_integral<_Hash>::value>,
        -: 1513:          class            = enable_if_t<!__is_allocator<_Pred>::value>,
        -: 1514:          class            = enable_if_t<__is_allocator<_Allocator>::value>>
        -: 1515:unordered_map(initializer_list<pair<_Key, _Tp>>,
        -: 1516:              typename allocator_traits<_Allocator>::size_type = 0,
        -: 1517:              _Hash                                            = _Hash(),
        -: 1518:              _Pred                                            = _Pred(),
        -: 1519:              _Allocator = _Allocator()) -> unordered_map<remove_const_t<_Key>, _Tp, _Hash, _Pred, _Allocator>;
        -: 1520:
        -: 1521:template <class _InputIterator,
        -: 1522:          class _Allocator,
        -: 1523:          class = enable_if_t<__has_input_iterator_category<_InputIterator>::value>,
        -: 1524:          class = enable_if_t<__is_allocator<_Allocator>::value>>
        -: 1525:unordered_map(_InputIterator, _InputIterator, typename allocator_traits<_Allocator>::size_type, _Allocator)
        -: 1526:    -> unordered_map<__iter_key_type<_InputIterator>,
        -: 1527:                     __iter_mapped_type<_InputIterator>,
        -: 1528:                     hash<__iter_key_type<_InputIterator>>,
        -: 1529:                     equal_to<__iter_key_type<_InputIterator>>,
        -: 1530:                     _Allocator>;
        -: 1531:
        -: 1532:template <class _InputIterator,
        -: 1533:          class _Allocator,
        -: 1534:          class = enable_if_t<__has_input_iterator_category<_InputIterator>::value>,
        -: 1535:          class = enable_if_t<__is_allocator<_Allocator>::value>>
        -: 1536:unordered_map(_InputIterator, _InputIterator, _Allocator)
        -: 1537:    -> unordered_map<__iter_key_type<_InputIterator>,
        -: 1538:                     __iter_mapped_type<_InputIterator>,
        -: 1539:                     hash<__iter_key_type<_InputIterator>>,
        -: 1540:                     equal_to<__iter_key_type<_InputIterator>>,
        -: 1541:                     _Allocator>;
        -: 1542:
        -: 1543:template <class _InputIterator,
        -: 1544:          class _Hash,
        -: 1545:          class _Allocator,
        -: 1546:          class = enable_if_t<__has_input_iterator_category<_InputIterator>::value>,
        -: 1547:          class = enable_if_t<!__is_allocator<_Hash>::value>,
        -: 1548:          class = enable_if_t<!is_integral<_Hash>::value>,
        -: 1549:          class = enable_if_t<__is_allocator<_Allocator>::value>>
        -: 1550:unordered_map(_InputIterator, _InputIterator, typename allocator_traits<_Allocator>::size_type, _Hash, _Allocator)
        -: 1551:    -> unordered_map<__iter_key_type<_InputIterator>,
        -: 1552:                     __iter_mapped_type<_InputIterator>,
        -: 1553:                     _Hash,
        -: 1554:                     equal_to<__iter_key_type<_InputIterator>>,
        -: 1555:                     _Allocator>;
        -: 1556:
        -: 1557:#  if _LIBCPP_STD_VER >= 23
        -: 1558:
        -: 1559:template <ranges::input_range _Range, class _Allocator, class = enable_if_t<__is_allocator<_Allocator>::value>>
        -: 1560:unordered_map(from_range_t, _Range&&, typename allocator_traits<_Allocator>::size_type, _Allocator)
        -: 1561:    -> unordered_map<__range_key_type<_Range>,
        -: 1562:                     __range_mapped_type<_Range>,
        -: 1563:                     hash<__range_key_type<_Range>>,
        -: 1564:                     equal_to<__range_key_type<_Range>>,
        -: 1565:                     _Allocator>;
        -: 1566:
        -: 1567:template <ranges::input_range _Range, class _Allocator, class = enable_if_t<__is_allocator<_Allocator>::value>>
        -: 1568:unordered_map(from_range_t, _Range&&, _Allocator)
        -: 1569:    -> unordered_map<__range_key_type<_Range>,
        -: 1570:                     __range_mapped_type<_Range>,
        -: 1571:                     hash<__range_key_type<_Range>>,
        -: 1572:                     equal_to<__range_key_type<_Range>>,
        -: 1573:                     _Allocator>;
        -: 1574:
        -: 1575:template <ranges::input_range _Range,
        -: 1576:          class _Hash,
        -: 1577:          class _Allocator,
        -: 1578:          class = enable_if_t<!__is_allocator<_Hash>::value>,
        -: 1579:          class = enable_if_t<!is_integral<_Hash>::value>,
        -: 1580:          class = enable_if_t<__is_allocator<_Allocator>::value>>
        -: 1581:unordered_map(from_range_t, _Range&&, typename allocator_traits<_Allocator>::size_type, _Hash, _Allocator)
        -: 1582:    -> unordered_map<__range_key_type<_Range>,
        -: 1583:                     __range_mapped_type<_Range>,
        -: 1584:                     _Hash,
        -: 1585:                     equal_to<__range_key_type<_Range>>,
        -: 1586:                     _Allocator>;
        -: 1587:
        -: 1588:#  endif
        -: 1589:
        -: 1590:template <class _Key, class _Tp, class _Allocator, class = enable_if_t<__is_allocator<_Allocator>::value>>
        -: 1591:unordered_map(initializer_list<pair<_Key, _Tp>>, typename allocator_traits<_Allocator>::size_type, _Allocator)
        -: 1592:    -> unordered_map<remove_const_t<_Key>, _Tp, hash<remove_const_t<_Key>>, equal_to<remove_const_t<_Key>>, _Allocator>;
        -: 1593:
        -: 1594:template <class _Key, class _Tp, class _Allocator, class = enable_if_t<__is_allocator<_Allocator>::value>>
        -: 1595:unordered_map(initializer_list<pair<_Key, _Tp>>, _Allocator)
        -: 1596:    -> unordered_map<remove_const_t<_Key>, _Tp, hash<remove_const_t<_Key>>, equal_to<remove_const_t<_Key>>, _Allocator>;
        -: 1597:
        -: 1598:template <class _Key,
        -: 1599:          class _Tp,
        -: 1600:          class _Hash,
        -: 1601:          class _Allocator,
        -: 1602:          class = enable_if_t<!__is_allocator<_Hash>::value>,
        -: 1603:          class = enable_if_t<!is_integral<_Hash>::value>,
        -: 1604:          class = enable_if_t<__is_allocator<_Allocator>::value>>
        -: 1605:unordered_map(initializer_list<pair<_Key, _Tp>>, typename allocator_traits<_Allocator>::size_type, _Hash, _Allocator)
        -: 1606:    -> unordered_map<remove_const_t<_Key>, _Tp, _Hash, equal_to<remove_const_t<_Key>>, _Allocator>;
        -: 1607:#endif
        -: 1608:
        -: 1609:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
        -: 1610:unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(size_type __n, const hasher& __hf, const key_equal& __eql)
        -: 1611:    : __table_(__hf, __eql) {
        -: 1612:  __table_.__rehash_unique(__n);
        -: 1613:}
        -: 1614:
        -: 1615:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
        -: 1616:unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        -: 1617:    size_type __n, const hasher& __hf, const key_equal& __eql, const allocator_type& __a)
        -: 1618:    : __table_(__hf, __eql, typename __table::allocator_type(__a)) {
        -: 1619:  __table_.__rehash_unique(__n);
        -: 1620:}
        -: 1621:
        -: 1622:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
        -: 1623:inline unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(const allocator_type& __a)
        -: 1624:    : __table_(typename __table::allocator_type(__a)) {}
        -: 1625:
        -: 1626:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
        -: 1627:template <class _InputIterator>
        -: 1628:unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(_InputIterator __first, _InputIterator __last) {
        -: 1629:  insert(__first, __last);
        -: 1630:}
        -: 1631:
        -: 1632:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
        -: 1633:template <class _InputIterator>
        -: 1634:unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        -: 1635:    _InputIterator __first, _InputIterator __last, size_type __n, const hasher& __hf, const key_equal& __eql)
        -: 1636:    : __table_(__hf, __eql) {
        -: 1637:  __table_.__rehash_unique(__n);
        -: 1638:  insert(__first, __last);
        -: 1639:}
        -: 1640:
        -: 1641:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
        -: 1642:template <class _InputIterator>
        -: 1643:unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        -: 1644:    _InputIterator __first,
        -: 1645:    _InputIterator __last,
        -: 1646:    size_type __n,
        -: 1647:    const hasher& __hf,
        -: 1648:    const key_equal& __eql,
        -: 1649:    const allocator_type& __a)
        -: 1650:    : __table_(__hf, __eql, typename __table::allocator_type(__a)) {
        -: 1651:  __table_.__rehash_unique(__n);
        -: 1652:  insert(__first, __last);
        -: 1653:}
        -: 1654:
        -: 1655:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
        -: 1656:unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(const unordered_map& __u) : __table_(__u.__table_) {
        -: 1657:  __table_.__rehash_unique(__u.bucket_count());
        -: 1658:  insert(__u.begin(), __u.end());
        -: 1659:}
        -: 1660:
        -: 1661:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
        -: 1662:unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(const unordered_map& __u, const allocator_type& __a)
        -: 1663:    : __table_(__u.__table_, typename __table::allocator_type(__a)) {
        -: 1664:  __table_.__rehash_unique(__u.bucket_count());
        -: 1665:  insert(__u.begin(), __u.end());
        -: 1666:}
        -: 1667:
        -: 1668:#ifndef _LIBCPP_CXX03_LANG
        -: 1669:
        -: 1670:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
        -: 1671:inline unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(unordered_map&& __u)
        -: 1672:    _NOEXCEPT_(is_nothrow_move_constructible<__table>::value)
        -: 1673:    : __table_(std::move(__u.__table_)) {}
        -: 1674:
        -: 1675:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
        -: 1676:unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(unordered_map&& __u, const allocator_type& __a)
        -: 1677:    : __table_(std::move(__u.__table_), typename __table::allocator_type(__a)) {
        -: 1678:  if (__a != __u.get_allocator()) {
        -: 1679:    iterator __i = __u.begin();
        -: 1680:    while (__u.size() != 0) {
        -: 1681:      __table_.__emplace_unique(__u.__table_.remove((__i++).__i_)->__get_value().__move());
        -: 1682:    }
        -: 1683:  }
        -: 1684:}
        -: 1685:
        -: 1686:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
        -: 1687:unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(initializer_list<value_type> __il) {
        -: 1688:  insert(__il.begin(), __il.end());
        -: 1689:}
        -: 1690:
        -: 1691:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
        -: 1692:unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        -: 1693:    initializer_list<value_type> __il, size_type __n, const hasher& __hf, const key_equal& __eql)
        -: 1694:    : __table_(__hf, __eql) {
        -: 1695:  __table_.__rehash_unique(__n);
        -: 1696:  insert(__il.begin(), __il.end());
        -: 1697:}
        -: 1698:
        -: 1699:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
        -: 1700:unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        -: 1701:    initializer_list<value_type> __il,
        -: 1702:    size_type __n,
        -: 1703:    const hasher& __hf,
        -: 1704:    const key_equal& __eql,
        -: 1705:    const allocator_type& __a)
        -: 1706:    : __table_(__hf, __eql, typename __table::allocator_type(__a)) {
        -: 1707:  __table_.__rehash_unique(__n);
        -: 1708:  insert(__il.begin(), __il.end());
        -: 1709:}
        -: 1710:
        -: 1711:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
        -: 1712:inline unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&
        -: 1713:unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator=(unordered_map&& __u)
        -: 1714:    _NOEXCEPT_(is_nothrow_move_assignable<__table>::value) {
        -: 1715:  __table_ = std::move(__u.__table_);
        -: 1716:  return *this;
        -: 1717:}
        -: 1718:
        -: 1719:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
        -: 1720:inline unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&
        -: 1721:unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator=(initializer_list<value_type> __il) {
        -: 1722:  __table_.__assign_unique(__il.begin(), __il.end());
        -: 1723:  return *this;
        -: 1724:}
        -: 1725:
        -: 1726:#endif // _LIBCPP_CXX03_LANG
        -: 1727:
        -: 1728:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
        -: 1729:template <class _InputIterator>
        -: 1730:inline void unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(_InputIterator __first, _InputIterator __last) {
        -: 1731:  for (; __first != __last; ++__first)
        -: 1732:    __table_.__insert_unique(*__first);
        -: 1733:}
        -: 1734:
        -: 1735:#ifndef _LIBCPP_CXX03_LANG
        -: 1736:
        -: 1737:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
        -: 1738:_Tp& unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator[](const key_type& __k) {
        -: 1739:  return __table_
        -: 1740:      .__emplace_unique_key_args(__k, piecewise_construct, std::forward_as_tuple(__k), std::forward_as_tuple())
        -: 1741:      .first->__get_value()
        -: 1742:      .second;
        -: 1743:}
        -: 1744:
        -: 1745:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
        -: 1746:_Tp& unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator[](key_type&& __k) {
        -: 1747:  return __table_
        -: 1748:      .__emplace_unique_key_args(
        -: 1749:          __k, piecewise_construct, std::forward_as_tuple(std::move(__k)), std::forward_as_tuple())
        -: 1750:      .first->__get_value()
        -: 1751:      .second;
        -: 1752:}
        -: 1753:#else // _LIBCPP_CXX03_LANG
        -: 1754:
        -: 1755:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
        -: 1756:typename unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__node_holder
        -: 1757:unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__construct_node_with_key(const key_type& __k) {
        -: 1758:  __node_allocator& __na = __table_.__node_alloc();
        -: 1759:  __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));
        -: 1760:  __node_traits::construct(__na, std::addressof(__h->__get_value().__get_value().first), __k);
        -: 1761:  __h.get_deleter().__first_constructed = true;
        -: 1762:  __node_traits::construct(__na, std::addressof(__h->__get_value().__get_value().second));
        -: 1763:  __h.get_deleter().__second_constructed = true;
        -: 1764:  return __h;
        -: 1765:}
        -: 1766:
        -: 1767:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
        -: 1768:_Tp& unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator[](const key_type& __k) {
        -: 1769:  iterator __i = find(__k);
        -: 1770:  if (__i != end())
        -: 1771:    return __i->second;
        -: 1772:  __node_holder __h        = __construct_node_with_key(__k);
        -: 1773:  pair<iterator, bool> __r = __table_.__node_insert_unique(__h.get());
        -: 1774:  __h.release();
        -: 1775:  return __r.first->second;
        -: 1776:}
        -: 1777:
        -: 1778:#endif // _LIBCPP_CXX03_LANG
        -: 1779:
        -: 1780:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
        -: 1781:_Tp& unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::at(const key_type& __k) {
        -: 1782:  iterator __i = find(__k);
        -: 1783:  if (__i == end())
        -: 1784:    __throw_out_of_range("unordered_map::at: key not found");
        -: 1785:  return __i->second;
        -: 1786:}
        -: 1787:
        -: 1788:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
        -: 1789:const _Tp& unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::at(const key_type& __k) const {
        -: 1790:  const_iterator __i = find(__k);
        -: 1791:  if (__i == end())
        -: 1792:    __throw_out_of_range("unordered_map::at: key not found");
        -: 1793:  return __i->second;
        -: 1794:}
        -: 1795:
        -: 1796:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
        -: 1797:inline _LIBCPP_HIDE_FROM_ABI void
        -: 1798:swap(unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x, unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
        -: 1799:    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y))) {
        -: 1800:  __x.swap(__y);
        -: 1801:}
        -: 1802:
        -: 1803:#if _LIBCPP_STD_VER >= 20
        -: 1804:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc, class _Predicate>
        -: 1805:inline _LIBCPP_HIDE_FROM_ABI typename unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type
        -: 1806:erase_if(unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __c, _Predicate __pred) {
        -: 1807:  return std::__libcpp_erase_if_container(__c, __pred);
        -: 1808:}
        -: 1809:#endif
        -: 1810:
        -: 1811:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
        -: 1812:_LIBCPP_HIDE_FROM_ABI bool operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
        -: 1813:                                      const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y) {
        -: 1814:  if (__x.size() != __y.size())
        -: 1815:    return false;
        -: 1816:  typedef typename unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::const_iterator const_iterator;
        -: 1817:  for (const_iterator __i = __x.begin(), __ex = __x.end(), __ey = __y.end(); __i != __ex; ++__i) {
        -: 1818:    const_iterator __j = __y.find(__i->first);
        -: 1819:    if (__j == __ey || !(*__i == *__j))
        -: 1820:      return false;
        -: 1821:  }
        -: 1822:  return true;
        -: 1823:}
        -: 1824:
        -: 1825:#if _LIBCPP_STD_VER <= 17
        -: 1826:
        -: 1827:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
        -: 1828:inline _LIBCPP_HIDE_FROM_ABI bool operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
        -: 1829:                                             const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y) {
        -: 1830:  return !(__x == __y);
        -: 1831:}
        -: 1832:
        -: 1833:#endif
        -: 1834:
        -: 1835:template <class _Key,
        -: 1836:          class _Tp,
        -: 1837:          class _Hash  = hash<_Key>,
        -: 1838:          class _Pred  = equal_to<_Key>,
        -: 1839:          class _Alloc = allocator<pair<const _Key, _Tp> > >
        -: 1840:class _LIBCPP_TEMPLATE_VIS unordered_multimap {
        -: 1841:public:
        -: 1842:  // types
        -: 1843:  typedef _Key key_type;
        -: 1844:  typedef _Tp mapped_type;
        -: 1845:  typedef __type_identity_t<_Hash> hasher;
        -: 1846:  typedef __type_identity_t<_Pred> key_equal;
        -: 1847:  typedef __type_identity_t<_Alloc> allocator_type;
        -: 1848:  typedef pair<const key_type, mapped_type> value_type;
        -: 1849:  typedef value_type& reference;
        -: 1850:  typedef const value_type& const_reference;
        -: 1851:  static_assert((is_same<value_type, typename allocator_type::value_type>::value),
        -: 1852:                "Allocator::value_type must be same type as value_type");
        -: 1853:
        -: 1854:private:
        -: 1855:  typedef __hash_value_type<key_type, mapped_type> __value_type;
        -: 1856:  typedef __unordered_map_hasher<key_type, __value_type, hasher, key_equal> __hasher;
        -: 1857:  typedef __unordered_map_equal<key_type, __value_type, key_equal, hasher> __key_equal;
        -: 1858:  typedef __rebind_alloc<allocator_traits<allocator_type>, __value_type> __allocator_type;
        -: 1859:
        -: 1860:  typedef __hash_table<__value_type, __hasher, __key_equal, __allocator_type> __table;
        -: 1861:
        -: 1862:  __table __table_;
        -: 1863:
        -: 1864:  typedef typename __table::_NodeTypes _NodeTypes;
        -: 1865:  typedef typename __table::__node_traits __node_traits;
        -: 1866:  typedef typename __table::__node_allocator __node_allocator;
        -: 1867:  typedef typename __table::__node __node;
        -: 1868:  typedef __hash_map_node_destructor<__node_allocator> _Dp;
        -: 1869:  typedef unique_ptr<__node, _Dp> __node_holder;
        -: 1870:  typedef allocator_traits<allocator_type> __alloc_traits;
        -: 1871:  static_assert((is_same<typename __node_traits::size_type, typename __alloc_traits::size_type>::value),
        -: 1872:                "Allocator uses different size_type for different types");
        -: 1873:
        -: 1874:  static_assert(is_same<allocator_type, __rebind_alloc<__alloc_traits, value_type> >::value,
        -: 1875:                "[allocator.requirements] states that rebinding an allocator to the same type should result in the "
        -: 1876:                "original allocator");
        -: 1877:
        -: 1878:public:
        -: 1879:  typedef typename __alloc_traits::pointer pointer;
        -: 1880:  typedef typename __alloc_traits::const_pointer const_pointer;
        -: 1881:  typedef typename __table::size_type size_type;
        -: 1882:  typedef typename __table::difference_type difference_type;
        -: 1883:
        -: 1884:  typedef __hash_map_iterator<typename __table::iterator> iterator;
        -: 1885:  typedef __hash_map_const_iterator<typename __table::const_iterator> const_iterator;
        -: 1886:  typedef __hash_map_iterator<typename __table::local_iterator> local_iterator;
        -: 1887:  typedef __hash_map_const_iterator<typename __table::const_local_iterator> const_local_iterator;
        -: 1888:
        -: 1889:#if _LIBCPP_STD_VER >= 17
        -: 1890:  typedef __map_node_handle<__node, allocator_type> node_type;
        -: 1891:#endif
        -: 1892:
        -: 1893:  template <class _Key2, class _Tp2, class _Hash2, class _Pred2, class _Alloc2>
        -: 1894:  friend class _LIBCPP_TEMPLATE_VIS unordered_map;
        -: 1895:  template <class _Key2, class _Tp2, class _Hash2, class _Pred2, class _Alloc2>
        -: 1896:  friend class _LIBCPP_TEMPLATE_VIS unordered_multimap;
        -: 1897:
        -: 1898:  _LIBCPP_HIDE_FROM_ABI unordered_multimap() _NOEXCEPT_(is_nothrow_default_constructible<__table>::value) {}
        -: 1899:  explicit _LIBCPP_HIDE_FROM_ABI
        -: 1900:  unordered_multimap(size_type __n, const hasher& __hf = hasher(), const key_equal& __eql = key_equal());
        -: 1901:  _LIBCPP_HIDE_FROM_ABI
        -: 1902:  unordered_multimap(size_type __n, const hasher& __hf, const key_equal& __eql, const allocator_type& __a);
        -: 1903:  template <class _InputIterator>
        -: 1904:  _LIBCPP_HIDE_FROM_ABI unordered_multimap(_InputIterator __first, _InputIterator __last);
        -: 1905:  template <class _InputIterator>
        -: 1906:  _LIBCPP_HIDE_FROM_ABI unordered_multimap(
        -: 1907:      _InputIterator __first,
        -: 1908:      _InputIterator __last,
        -: 1909:      size_type __n,
        -: 1910:      const hasher& __hf     = hasher(),
        -: 1911:      const key_equal& __eql = key_equal());
        -: 1912:  template <class _InputIterator>
        -: 1913:  _LIBCPP_HIDE_FROM_ABI unordered_multimap(
        -: 1914:      _InputIterator __first,
        -: 1915:      _InputIterator __last,
        -: 1916:      size_type __n,
        -: 1917:      const hasher& __hf,
        -: 1918:      const key_equal& __eql,
        -: 1919:      const allocator_type& __a);
        -: 1920:
        -: 1921:#if _LIBCPP_STD_VER >= 23
        -: 1922:  template <_ContainerCompatibleRange<value_type> _Range>
        -: 1923:  _LIBCPP_HIDE_FROM_ABI unordered_multimap(
        -: 1924:      from_range_t,
        -: 1925:      _Range&& __range,
        -: 1926:      size_type __n             = /*implementation-defined*/ 0,
        -: 1927:      const hasher& __hf        = hasher(),
        -: 1928:      const key_equal& __eql    = key_equal(),
        -: 1929:      const allocator_type& __a = allocator_type())
        -: 1930:      : __table_(__hf, __eql, typename __table::allocator_type(__a)) {
        -: 1931:    if (__n > 0) {
        -: 1932:      __table_.__rehash_multi(__n);
        -: 1933:    }
        -: 1934:    insert_range(std::forward<_Range>(__range));
        -: 1935:  }
        -: 1936:#endif
        -: 1937:
        -: 1938:  _LIBCPP_HIDE_FROM_ABI explicit unordered_multimap(const allocator_type& __a);
        -: 1939:  _LIBCPP_HIDE_FROM_ABI unordered_multimap(const unordered_multimap& __u);
        -: 1940:  _LIBCPP_HIDE_FROM_ABI unordered_multimap(const unordered_multimap& __u, const allocator_type& __a);
        -: 1941:#ifndef _LIBCPP_CXX03_LANG
        -: 1942:  _LIBCPP_HIDE_FROM_ABI unordered_multimap(unordered_multimap&& __u)
        -: 1943:      _NOEXCEPT_(is_nothrow_move_constructible<__table>::value);
        -: 1944:  _LIBCPP_HIDE_FROM_ABI unordered_multimap(unordered_multimap&& __u, const allocator_type& __a);
        -: 1945:  _LIBCPP_HIDE_FROM_ABI unordered_multimap(initializer_list<value_type> __il);
        -: 1946:  _LIBCPP_HIDE_FROM_ABI unordered_multimap(
        -: 1947:      initializer_list<value_type> __il,
        -: 1948:      size_type __n,
        -: 1949:      const hasher& __hf     = hasher(),
        -: 1950:      const key_equal& __eql = key_equal());
        -: 1951:  _LIBCPP_HIDE_FROM_ABI unordered_multimap(
        -: 1952:      initializer_list<value_type> __il,
        -: 1953:      size_type __n,
        -: 1954:      const hasher& __hf,
        -: 1955:      const key_equal& __eql,
        -: 1956:      const allocator_type& __a);
        -: 1957:#endif // _LIBCPP_CXX03_LANG
        -: 1958:#if _LIBCPP_STD_VER >= 14
        -: 1959:  _LIBCPP_HIDE_FROM_ABI unordered_multimap(size_type __n, const allocator_type& __a)
        -: 1960:      : unordered_multimap(__n, hasher(), key_equal(), __a) {}
        -: 1961:  _LIBCPP_HIDE_FROM_ABI unordered_multimap(size_type __n, const hasher& __hf, const allocator_type& __a)
        -: 1962:      : unordered_multimap(__n, __hf, key_equal(), __a) {}
        -: 1963:  template <class _InputIterator>
        -: 1964:  _LIBCPP_HIDE_FROM_ABI
        -: 1965:  unordered_multimap(_InputIterator __first, _InputIterator __last, size_type __n, const allocator_type& __a)
        -: 1966:      : unordered_multimap(__first, __last, __n, hasher(), key_equal(), __a) {}
        -: 1967:  template <class _InputIterator>
        -: 1968:  _LIBCPP_HIDE_FROM_ABI unordered_multimap(
        -: 1969:      _InputIterator __first, _InputIterator __last, size_type __n, const hasher& __hf, const allocator_type& __a)
        -: 1970:      : unordered_multimap(__first, __last, __n, __hf, key_equal(), __a) {}
        -: 1971:
        -: 1972:#  if _LIBCPP_STD_VER >= 23
        -: 1973:  template <_ContainerCompatibleRange<value_type> _Range>
        -: 1974:  _LIBCPP_HIDE_FROM_ABI unordered_multimap(from_range_t, _Range&& __range, size_type __n, const allocator_type& __a)
        -: 1975:      : unordered_multimap(from_range, std::forward<_Range>(__range), __n, hasher(), key_equal(), __a) {}
        -: 1976:
        -: 1977:  template <_ContainerCompatibleRange<value_type> _Range>
        -: 1978:  _LIBCPP_HIDE_FROM_ABI
        -: 1979:  unordered_multimap(from_range_t, _Range&& __range, size_type __n, const hasher& __hf, const allocator_type& __a)
        -: 1980:      : unordered_multimap(from_range, std::forward<_Range>(__range), __n, __hf, key_equal(), __a) {}
        -: 1981:#  endif
        -: 1982:
        -: 1983:  _LIBCPP_HIDE_FROM_ABI unordered_multimap(initializer_list<value_type> __il, size_type __n, const allocator_type& __a)
        -: 1984:      : unordered_multimap(__il, __n, hasher(), key_equal(), __a) {}
        -: 1985:  _LIBCPP_HIDE_FROM_ABI
        -: 1986:  unordered_multimap(initializer_list<value_type> __il, size_type __n, const hasher& __hf, const allocator_type& __a)
        -: 1987:      : unordered_multimap(__il, __n, __hf, key_equal(), __a) {}
        -: 1988:#endif
        -: 1989:  _LIBCPP_HIDE_FROM_ABI ~unordered_multimap() {
        -: 1990:    static_assert(sizeof(std::__diagnose_unordered_container_requirements<_Key, _Hash, _Pred>(0)), "");
        -: 1991:  }
        -: 1992:
        -: 1993:  _LIBCPP_HIDE_FROM_ABI unordered_multimap& operator=(const unordered_multimap& __u) {
        -: 1994:#ifndef _LIBCPP_CXX03_LANG
        -: 1995:    __table_ = __u.__table_;
        -: 1996:#else
        -: 1997:    if (this != std::addressof(__u)) {
        -: 1998:      __table_.clear();
        -: 1999:      __table_.hash_function()   = __u.__table_.hash_function();
        -: 2000:      __table_.key_eq()          = __u.__table_.key_eq();
        -: 2001:      __table_.max_load_factor() = __u.__table_.max_load_factor();
        -: 2002:      __table_.__copy_assign_alloc(__u.__table_);
        -: 2003:      insert(__u.begin(), __u.end());
        -: 2004:    }
        -: 2005:#endif
        -: 2006:    return *this;
        -: 2007:  }
        -: 2008:#ifndef _LIBCPP_CXX03_LANG
        -: 2009:  _LIBCPP_HIDE_FROM_ABI unordered_multimap& operator=(unordered_multimap&& __u)
        -: 2010:      _NOEXCEPT_(is_nothrow_move_assignable<__table>::value);
        -: 2011:  _LIBCPP_HIDE_FROM_ABI unordered_multimap& operator=(initializer_list<value_type> __il);
        -: 2012:#endif // _LIBCPP_CXX03_LANG
        -: 2013:
        -: 2014:  _LIBCPP_HIDE_FROM_ABI allocator_type get_allocator() const _NOEXCEPT {
        -: 2015:    return allocator_type(__table_.__node_alloc());
        -: 2016:  }
        -: 2017:
        -: 2018:  _LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_HIDE_FROM_ABI bool empty() const _NOEXCEPT { return __table_.size() == 0; }
        -: 2019:  _LIBCPP_HIDE_FROM_ABI size_type size() const _NOEXCEPT { return __table_.size(); }
        -: 2020:  _LIBCPP_HIDE_FROM_ABI size_type max_size() const _NOEXCEPT { return __table_.max_size(); }
        -: 2021:
        -: 2022:  _LIBCPP_HIDE_FROM_ABI iterator begin() _NOEXCEPT { return __table_.begin(); }
        -: 2023:  _LIBCPP_HIDE_FROM_ABI iterator end() _NOEXCEPT { return __table_.end(); }
        -: 2024:  _LIBCPP_HIDE_FROM_ABI const_iterator begin() const _NOEXCEPT { return __table_.begin(); }
        -: 2025:  _LIBCPP_HIDE_FROM_ABI const_iterator end() const _NOEXCEPT { return __table_.end(); }
        -: 2026:  _LIBCPP_HIDE_FROM_ABI const_iterator cbegin() const _NOEXCEPT { return __table_.begin(); }
        -: 2027:  _LIBCPP_HIDE_FROM_ABI const_iterator cend() const _NOEXCEPT { return __table_.end(); }
        -: 2028:
        -: 2029:  _LIBCPP_HIDE_FROM_ABI iterator insert(const value_type& __x) { return __table_.__insert_multi(__x); }
        -: 2030:
        -: 2031:  _LIBCPP_HIDE_FROM_ABI iterator insert(const_iterator __p, const value_type& __x) {
        -: 2032:    return __table_.__insert_multi(__p.__i_, __x);
        -: 2033:  }
        -: 2034:
        -: 2035:  template <class _InputIterator>
        -: 2036:  _LIBCPP_HIDE_FROM_ABI void insert(_InputIterator __first, _InputIterator __last);
        -: 2037:
        -: 2038:#if _LIBCPP_STD_VER >= 23
        -: 2039:  template <_ContainerCompatibleRange<value_type> _Range>
        -: 2040:  _LIBCPP_HIDE_FROM_ABI void insert_range(_Range&& __range) {
        -: 2041:    for (auto&& __element : __range) {
        -: 2042:      __table_.__insert_multi(std::forward<decltype(__element)>(__element));
        -: 2043:    }
        -: 2044:  }
        -: 2045:#endif
        -: 2046:
        -: 2047:#ifndef _LIBCPP_CXX03_LANG
        -: 2048:  _LIBCPP_HIDE_FROM_ABI void insert(initializer_list<value_type> __il) { insert(__il.begin(), __il.end()); }
        -: 2049:  _LIBCPP_HIDE_FROM_ABI iterator insert(value_type&& __x) { return __table_.__insert_multi(std::move(__x)); }
        -: 2050:
        -: 2051:  _LIBCPP_HIDE_FROM_ABI iterator insert(const_iterator __p, value_type&& __x) {
        -: 2052:    return __table_.__insert_multi(__p.__i_, std::move(__x));
        -: 2053:  }
        -: 2054:
        -: 2055:  template <class _Pp, class = __enable_if_t<is_constructible<value_type, _Pp>::value> >
        -: 2056:  _LIBCPP_HIDE_FROM_ABI iterator insert(_Pp&& __x) {
        -: 2057:    return __table_.__insert_multi(std::forward<_Pp>(__x));
        -: 2058:  }
        -: 2059:
        -: 2060:  template <class _Pp, class = __enable_if_t<is_constructible<value_type, _Pp>::value> >
        -: 2061:  _LIBCPP_HIDE_FROM_ABI iterator insert(const_iterator __p, _Pp&& __x) {
        -: 2062:    return __table_.__insert_multi(__p.__i_, std::forward<_Pp>(__x));
        -: 2063:  }
        -: 2064:
        -: 2065:  template <class... _Args>
        -: 2066:  _LIBCPP_HIDE_FROM_ABI iterator emplace(_Args&&... __args) {
        -: 2067:    return __table_.__emplace_multi(std::forward<_Args>(__args)...);
        -: 2068:  }
        -: 2069:
        -: 2070:  template <class... _Args>
        -: 2071:  _LIBCPP_HIDE_FROM_ABI iterator emplace_hint(const_iterator __p, _Args&&... __args) {
        -: 2072:    return __table_.__emplace_hint_multi(__p.__i_, std::forward<_Args>(__args)...);
        -: 2073:  }
        -: 2074:#endif // _LIBCPP_CXX03_LANG
        -: 2075:
        -: 2076:  _LIBCPP_HIDE_FROM_ABI iterator erase(const_iterator __p) { return __table_.erase(__p.__i_); }
        -: 2077:  _LIBCPP_HIDE_FROM_ABI iterator erase(iterator __p) { return __table_.erase(__p.__i_); }
        -: 2078:  _LIBCPP_HIDE_FROM_ABI size_type erase(const key_type& __k) { return __table_.__erase_multi(__k); }
        -: 2079:  _LIBCPP_HIDE_FROM_ABI iterator erase(const_iterator __first, const_iterator __last) {
        -: 2080:    return __table_.erase(__first.__i_, __last.__i_);
        -: 2081:  }
        -: 2082:  _LIBCPP_HIDE_FROM_ABI void clear() _NOEXCEPT { __table_.clear(); }
        -: 2083:
        -: 2084:#if _LIBCPP_STD_VER >= 17
        -: 2085:  _LIBCPP_HIDE_FROM_ABI iterator insert(node_type&& __nh) {
        -: 2086:    _LIBCPP_ASSERT_COMPATIBLE_ALLOCATOR(__nh.empty() || __nh.get_allocator() == get_allocator(),
        -: 2087:                                        "node_type with incompatible allocator passed to unordered_multimap::insert()");
        -: 2088:    return __table_.template __node_handle_insert_multi<node_type>(std::move(__nh));
        -: 2089:  }
        -: 2090:  _LIBCPP_HIDE_FROM_ABI iterator insert(const_iterator __hint, node_type&& __nh) {
        -: 2091:    _LIBCPP_ASSERT_COMPATIBLE_ALLOCATOR(__nh.empty() || __nh.get_allocator() == get_allocator(),
        -: 2092:                                        "node_type with incompatible allocator passed to unordered_multimap::insert()");
        -: 2093:    return __table_.template __node_handle_insert_multi<node_type>(__hint.__i_, std::move(__nh));
        -: 2094:  }
        -: 2095:  _LIBCPP_HIDE_FROM_ABI node_type extract(key_type const& __key) {
        -: 2096:    return __table_.template __node_handle_extract<node_type>(__key);
        -: 2097:  }
        -: 2098:  _LIBCPP_HIDE_FROM_ABI node_type extract(const_iterator __it) {
        -: 2099:    return __table_.template __node_handle_extract<node_type>(__it.__i_);
        -: 2100:  }
        -: 2101:
        -: 2102:  template <class _H2, class _P2>
        -: 2103:  _LIBCPP_HIDE_FROM_ABI void merge(unordered_multimap<key_type, mapped_type, _H2, _P2, allocator_type>& __source) {
        -: 2104:    _LIBCPP_ASSERT_COMPATIBLE_ALLOCATOR(
        -: 2105:        __source.get_allocator() == get_allocator(), "merging container with incompatible allocator");
        -: 2106:    return __table_.__node_handle_merge_multi(__source.__table_);
        -: 2107:  }
        -: 2108:  template <class _H2, class _P2>
        -: 2109:  _LIBCPP_HIDE_FROM_ABI void merge(unordered_multimap<key_type, mapped_type, _H2, _P2, allocator_type>&& __source) {
        -: 2110:    _LIBCPP_ASSERT_COMPATIBLE_ALLOCATOR(
        -: 2111:        __source.get_allocator() == get_allocator(), "merging container with incompatible allocator");
        -: 2112:    return __table_.__node_handle_merge_multi(__source.__table_);
        -: 2113:  }
        -: 2114:  template <class _H2, class _P2>
        -: 2115:  _LIBCPP_HIDE_FROM_ABI void merge(unordered_map<key_type, mapped_type, _H2, _P2, allocator_type>& __source) {
        -: 2116:    _LIBCPP_ASSERT_COMPATIBLE_ALLOCATOR(
        -: 2117:        __source.get_allocator() == get_allocator(), "merging container with incompatible allocator");
        -: 2118:    return __table_.__node_handle_merge_multi(__source.__table_);
        -: 2119:  }
        -: 2120:  template <class _H2, class _P2>
        -: 2121:  _LIBCPP_HIDE_FROM_ABI void merge(unordered_map<key_type, mapped_type, _H2, _P2, allocator_type>&& __source) {
        -: 2122:    _LIBCPP_ASSERT_COMPATIBLE_ALLOCATOR(
        -: 2123:        __source.get_allocator() == get_allocator(), "merging container with incompatible allocator");
        -: 2124:    return __table_.__node_handle_merge_multi(__source.__table_);
        -: 2125:  }
        -: 2126:#endif
        -: 2127:
        -: 2128:  _LIBCPP_HIDE_FROM_ABI void swap(unordered_multimap& __u) _NOEXCEPT_(__is_nothrow_swappable<__table>::value) {
        -: 2129:    __table_.swap(__u.__table_);
        -: 2130:  }
        -: 2131:
        -: 2132:  _LIBCPP_HIDE_FROM_ABI hasher hash_function() const { return __table_.hash_function().hash_function(); }
        -: 2133:  _LIBCPP_HIDE_FROM_ABI key_equal key_eq() const { return __table_.key_eq().key_eq(); }
        -: 2134:
        -: 2135:  _LIBCPP_HIDE_FROM_ABI iterator find(const key_type& __k) { return __table_.find(__k); }
        -: 2136:  _LIBCPP_HIDE_FROM_ABI const_iterator find(const key_type& __k) const { return __table_.find(__k); }
        -: 2137:#if _LIBCPP_STD_VER >= 20
        -: 2138:  template <class _K2,
        -: 2139:            enable_if_t<__is_transparent<hasher, _K2>::value && __is_transparent<key_equal, _K2>::value>* = nullptr>
        -: 2140:  _LIBCPP_HIDE_FROM_ABI iterator find(const _K2& __k) {
        -: 2141:    return __table_.find(__k);
        -: 2142:  }
        -: 2143:  template <class _K2,
        -: 2144:            enable_if_t<__is_transparent<hasher, _K2>::value && __is_transparent<key_equal, _K2>::value>* = nullptr>
        -: 2145:  _LIBCPP_HIDE_FROM_ABI const_iterator find(const _K2& __k) const {
        -: 2146:    return __table_.find(__k);
        -: 2147:  }
        -: 2148:#endif // _LIBCPP_STD_VER >= 20
        -: 2149:
        -: 2150:  _LIBCPP_HIDE_FROM_ABI size_type count(const key_type& __k) const { return __table_.__count_multi(__k); }
        -: 2151:#if _LIBCPP_STD_VER >= 20
        -: 2152:  template <class _K2,
        -: 2153:            enable_if_t<__is_transparent<hasher, _K2>::value && __is_transparent<key_equal, _K2>::value>* = nullptr>
        -: 2154:  _LIBCPP_HIDE_FROM_ABI size_type count(const _K2& __k) const {
        -: 2155:    return __table_.__count_multi(__k);
        -: 2156:  }
        -: 2157:#endif // _LIBCPP_STD_VER >= 20
        -: 2158:
        -: 2159:#if _LIBCPP_STD_VER >= 20
        -: 2160:  _LIBCPP_HIDE_FROM_ABI bool contains(const key_type& __k) const { return find(__k) != end(); }
        -: 2161:
        -: 2162:  template <class _K2,
        -: 2163:            enable_if_t<__is_transparent<hasher, _K2>::value && __is_transparent<key_equal, _K2>::value>* = nullptr>
        -: 2164:  _LIBCPP_HIDE_FROM_ABI bool contains(const _K2& __k) const {
        -: 2165:    return find(__k) != end();
        -: 2166:  }
        -: 2167:#endif // _LIBCPP_STD_VER >= 20
        -: 2168:
        -: 2169:  _LIBCPP_HIDE_FROM_ABI pair<iterator, iterator> equal_range(const key_type& __k) {
        -: 2170:    return __table_.__equal_range_multi(__k);
        -: 2171:  }
        -: 2172:  _LIBCPP_HIDE_FROM_ABI pair<const_iterator, const_iterator> equal_range(const key_type& __k) const {
        -: 2173:    return __table_.__equal_range_multi(__k);
        -: 2174:  }
        -: 2175:#if _LIBCPP_STD_VER >= 20
        -: 2176:  template <class _K2,
        -: 2177:            enable_if_t<__is_transparent<hasher, _K2>::value && __is_transparent<key_equal, _K2>::value>* = nullptr>
        -: 2178:  _LIBCPP_HIDE_FROM_ABI pair<iterator, iterator> equal_range(const _K2& __k) {
        -: 2179:    return __table_.__equal_range_multi(__k);
        -: 2180:  }
        -: 2181:  template <class _K2,
        -: 2182:            enable_if_t<__is_transparent<hasher, _K2>::value && __is_transparent<key_equal, _K2>::value>* = nullptr>
        -: 2183:  _LIBCPP_HIDE_FROM_ABI pair<const_iterator, const_iterator> equal_range(const _K2& __k) const {
        -: 2184:    return __table_.__equal_range_multi(__k);
        -: 2185:  }
        -: 2186:#endif // _LIBCPP_STD_VER >= 20
        -: 2187:
        -: 2188:  _LIBCPP_HIDE_FROM_ABI size_type bucket_count() const _NOEXCEPT { return __table_.bucket_count(); }
        -: 2189:  _LIBCPP_HIDE_FROM_ABI size_type max_bucket_count() const _NOEXCEPT { return __table_.max_bucket_count(); }
        -: 2190:
        -: 2191:  _LIBCPP_HIDE_FROM_ABI size_type bucket_size(size_type __n) const { return __table_.bucket_size(__n); }
        -: 2192:  _LIBCPP_HIDE_FROM_ABI size_type bucket(const key_type& __k) const { return __table_.bucket(__k); }
        -: 2193:
        -: 2194:  _LIBCPP_HIDE_FROM_ABI local_iterator begin(size_type __n) { return __table_.begin(__n); }
        -: 2195:  _LIBCPP_HIDE_FROM_ABI local_iterator end(size_type __n) { return __table_.end(__n); }
        -: 2196:  _LIBCPP_HIDE_FROM_ABI const_local_iterator begin(size_type __n) const { return __table_.cbegin(__n); }
        -: 2197:  _LIBCPP_HIDE_FROM_ABI const_local_iterator end(size_type __n) const { return __table_.cend(__n); }
        -: 2198:  _LIBCPP_HIDE_FROM_ABI const_local_iterator cbegin(size_type __n) const { return __table_.cbegin(__n); }
        -: 2199:  _LIBCPP_HIDE_FROM_ABI const_local_iterator cend(size_type __n) const { return __table_.cend(__n); }
        -: 2200:
        -: 2201:  _LIBCPP_HIDE_FROM_ABI float load_factor() const _NOEXCEPT { return __table_.load_factor(); }
        -: 2202:  _LIBCPP_HIDE_FROM_ABI float max_load_factor() const _NOEXCEPT { return __table_.max_load_factor(); }
        -: 2203:  _LIBCPP_HIDE_FROM_ABI void max_load_factor(float __mlf) { __table_.max_load_factor(__mlf); }
        -: 2204:  _LIBCPP_HIDE_FROM_ABI void rehash(size_type __n) { __table_.__rehash_multi(__n); }
        -: 2205:  _LIBCPP_HIDE_FROM_ABI void reserve(size_type __n) { __table_.__reserve_multi(__n); }
        -: 2206:};
        -: 2207:
        -: 2208:#if _LIBCPP_STD_VER >= 17
        -: 2209:template <class _InputIterator,
        -: 2210:          class _Hash      = hash<__iter_key_type<_InputIterator>>,
        -: 2211:          class _Pred      = equal_to<__iter_key_type<_InputIterator>>,
        -: 2212:          class _Allocator = allocator<__iter_to_alloc_type<_InputIterator>>,
        -: 2213:          class            = enable_if_t<__has_input_iterator_category<_InputIterator>::value>,
        -: 2214:          class            = enable_if_t<!__is_allocator<_Hash>::value>,
        -: 2215:          class            = enable_if_t<!is_integral<_Hash>::value>,
        -: 2216:          class            = enable_if_t<!__is_allocator<_Pred>::value>,
        -: 2217:          class            = enable_if_t<__is_allocator<_Allocator>::value>>
        -: 2218:unordered_multimap(_InputIterator,
        -: 2219:                   _InputIterator,
        -: 2220:                   typename allocator_traits<_Allocator>::size_type = 0,
        -: 2221:                   _Hash                                            = _Hash(),
        -: 2222:                   _Pred                                            = _Pred(),
        -: 2223:                   _Allocator                                       = _Allocator())
        -: 2224:    -> unordered_multimap<__iter_key_type<_InputIterator>,
        -: 2225:                          __iter_mapped_type<_InputIterator>,
        -: 2226:                          _Hash,
        -: 2227:                          _Pred,
        -: 2228:                          _Allocator>;
        -: 2229:
        -: 2230:#  if _LIBCPP_STD_VER >= 23
        -: 2231:template <ranges::input_range _Range,
        -: 2232:          class _Hash      = hash<__range_key_type<_Range>>,
        -: 2233:          class _Pred      = equal_to<__range_key_type<_Range>>,
        -: 2234:          class _Allocator = allocator<__range_to_alloc_type<_Range>>,
        -: 2235:          class            = enable_if_t<!__is_allocator<_Hash>::value>,
        -: 2236:          class            = enable_if_t<!is_integral<_Hash>::value>,
        -: 2237:          class            = enable_if_t<!__is_allocator<_Pred>::value>,
        -: 2238:          class            = enable_if_t<__is_allocator<_Allocator>::value>>
        -: 2239:unordered_multimap(from_range_t,
        -: 2240:                   _Range&&,
        -: 2241:                   typename allocator_traits<_Allocator>::size_type = 0,
        -: 2242:                   _Hash                                            = _Hash(),
        -: 2243:                   _Pred                                            = _Pred(),
        -: 2244:                   _Allocator                                       = _Allocator())
        -: 2245:    -> unordered_multimap<__range_key_type<_Range>, __range_mapped_type<_Range>, _Hash, _Pred, _Allocator>;
        -: 2246:#  endif
        -: 2247:
        -: 2248:template <class _Key,
        -: 2249:          class _Tp,
        -: 2250:          class _Hash      = hash<remove_const_t<_Key>>,
        -: 2251:          class _Pred      = equal_to<remove_const_t<_Key>>,
        -: 2252:          class _Allocator = allocator<pair<const _Key, _Tp>>,
        -: 2253:          class            = enable_if_t<!__is_allocator<_Hash>::value>,
        -: 2254:          class            = enable_if_t<!is_integral<_Hash>::value>,
        -: 2255:          class            = enable_if_t<!__is_allocator<_Pred>::value>,
        -: 2256:          class            = enable_if_t<__is_allocator<_Allocator>::value>>
        -: 2257:unordered_multimap(initializer_list<pair<_Key, _Tp>>,
        -: 2258:                   typename allocator_traits<_Allocator>::size_type = 0,
        -: 2259:                   _Hash                                            = _Hash(),
        -: 2260:                   _Pred                                            = _Pred(),
        -: 2261:                   _Allocator                                       = _Allocator())
        -: 2262:    -> unordered_multimap<remove_const_t<_Key>, _Tp, _Hash, _Pred, _Allocator>;
        -: 2263:
        -: 2264:template <class _InputIterator,
        -: 2265:          class _Allocator,
        -: 2266:          class = enable_if_t<__has_input_iterator_category<_InputIterator>::value>,
        -: 2267:          class = enable_if_t<__is_allocator<_Allocator>::value>>
        -: 2268:unordered_multimap(_InputIterator, _InputIterator, typename allocator_traits<_Allocator>::size_type, _Allocator)
        -: 2269:    -> unordered_multimap<__iter_key_type<_InputIterator>,
        -: 2270:                          __iter_mapped_type<_InputIterator>,
        -: 2271:                          hash<__iter_key_type<_InputIterator>>,
        -: 2272:                          equal_to<__iter_key_type<_InputIterator>>,
        -: 2273:                          _Allocator>;
        -: 2274:
        -: 2275:template <class _InputIterator,
        -: 2276:          class _Allocator,
        -: 2277:          class = enable_if_t<__has_input_iterator_category<_InputIterator>::value>,
        -: 2278:          class = enable_if_t<__is_allocator<_Allocator>::value>>
        -: 2279:unordered_multimap(_InputIterator, _InputIterator, _Allocator)
        -: 2280:    -> unordered_multimap<__iter_key_type<_InputIterator>,
        -: 2281:                          __iter_mapped_type<_InputIterator>,
        -: 2282:                          hash<__iter_key_type<_InputIterator>>,
        -: 2283:                          equal_to<__iter_key_type<_InputIterator>>,
        -: 2284:                          _Allocator>;
        -: 2285:
        -: 2286:template <class _InputIterator,
        -: 2287:          class _Hash,
        -: 2288:          class _Allocator,
        -: 2289:          class = enable_if_t<__has_input_iterator_category<_InputIterator>::value>,
        -: 2290:          class = enable_if_t<!__is_allocator<_Hash>::value>,
        -: 2291:          class = enable_if_t<!is_integral<_Hash>::value>,
        -: 2292:          class = enable_if_t<__is_allocator<_Allocator>::value>>
        -: 2293:unordered_multimap(_InputIterator, _InputIterator, typename allocator_traits<_Allocator>::size_type, _Hash, _Allocator)
        -: 2294:    -> unordered_multimap<__iter_key_type<_InputIterator>,
        -: 2295:                          __iter_mapped_type<_InputIterator>,
        -: 2296:                          _Hash,
        -: 2297:                          equal_to<__iter_key_type<_InputIterator>>,
        -: 2298:                          _Allocator>;
        -: 2299:
        -: 2300:#  if _LIBCPP_STD_VER >= 23
        -: 2301:
        -: 2302:template <ranges::input_range _Range, class _Allocator, class = enable_if_t<__is_allocator<_Allocator>::value>>
        -: 2303:unordered_multimap(from_range_t, _Range&&, typename allocator_traits<_Allocator>::size_type, _Allocator)
        -: 2304:    -> unordered_multimap<__range_key_type<_Range>,
        -: 2305:                          __range_mapped_type<_Range>,
        -: 2306:                          hash<__range_key_type<_Range>>,
        -: 2307:                          equal_to<__range_key_type<_Range>>,
        -: 2308:                          _Allocator>;
        -: 2309:
        -: 2310:template <ranges::input_range _Range, class _Allocator, class = enable_if_t<__is_allocator<_Allocator>::value>>
        -: 2311:unordered_multimap(from_range_t, _Range&&, _Allocator)
        -: 2312:    -> unordered_multimap<__range_key_type<_Range>,
        -: 2313:                          __range_mapped_type<_Range>,
        -: 2314:                          hash<__range_key_type<_Range>>,
        -: 2315:                          equal_to<__range_key_type<_Range>>,
        -: 2316:                          _Allocator>;
        -: 2317:
        -: 2318:template <ranges::input_range _Range,
        -: 2319:          class _Hash,
        -: 2320:          class _Allocator,
        -: 2321:          class = enable_if_t<!__is_allocator<_Hash>::value>,
        -: 2322:          class = enable_if_t<!is_integral<_Hash>::value>,
        -: 2323:          class = enable_if_t<__is_allocator<_Allocator>::value>>
        -: 2324:unordered_multimap(from_range_t, _Range&&, typename allocator_traits<_Allocator>::size_type, _Hash, _Allocator)
        -: 2325:    -> unordered_multimap<__range_key_type<_Range>,
        -: 2326:                          __range_mapped_type<_Range>,
        -: 2327:                          _Hash,
        -: 2328:                          equal_to<__range_key_type<_Range>>,
        -: 2329:                          _Allocator>;
        -: 2330:
        -: 2331:#  endif
        -: 2332:
        -: 2333:template <class _Key, class _Tp, class _Allocator, class = enable_if_t<__is_allocator<_Allocator>::value>>
        -: 2334:unordered_multimap(initializer_list<pair<_Key, _Tp>>, typename allocator_traits<_Allocator>::size_type, _Allocator)
        -: 2335:    -> unordered_multimap<remove_const_t<_Key>,
        -: 2336:                          _Tp,
        -: 2337:                          hash<remove_const_t<_Key>>,
        -: 2338:                          equal_to<remove_const_t<_Key>>,
        -: 2339:                          _Allocator>;
        -: 2340:
        -: 2341:template <class _Key, class _Tp, class _Allocator, class = enable_if_t<__is_allocator<_Allocator>::value>>
        -: 2342:unordered_multimap(initializer_list<pair<_Key, _Tp>>, _Allocator)
        -: 2343:    -> unordered_multimap<remove_const_t<_Key>,
        -: 2344:                          _Tp,
        -: 2345:                          hash<remove_const_t<_Key>>,
        -: 2346:                          equal_to<remove_const_t<_Key>>,
        -: 2347:                          _Allocator>;
        -: 2348:
        -: 2349:template <class _Key,
        -: 2350:          class _Tp,
        -: 2351:          class _Hash,
        -: 2352:          class _Allocator,
        -: 2353:          class = enable_if_t<!__is_allocator<_Hash>::value>,
        -: 2354:          class = enable_if_t<!is_integral<_Hash>::value>,
        -: 2355:          class = enable_if_t<__is_allocator<_Allocator>::value>>
        -: 2356:unordered_multimap(
        -: 2357:    initializer_list<pair<_Key, _Tp>>, typename allocator_traits<_Allocator>::size_type, _Hash, _Allocator)
        -: 2358:    -> unordered_multimap<remove_const_t<_Key>, _Tp, _Hash, equal_to<remove_const_t<_Key>>, _Allocator>;
        -: 2359:#endif
        -: 2360:
        -: 2361:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
        -: 2362:unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        -: 2363:    size_type __n, const hasher& __hf, const key_equal& __eql)
        -: 2364:    : __table_(__hf, __eql) {
        -: 2365:  __table_.__rehash_multi(__n);
        -: 2366:}
        -: 2367:
        -: 2368:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
        -: 2369:unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        -: 2370:    size_type __n, const hasher& __hf, const key_equal& __eql, const allocator_type& __a)
        -: 2371:    : __table_(__hf, __eql, typename __table::allocator_type(__a)) {
        -: 2372:  __table_.__rehash_multi(__n);
        -: 2373:}
        -: 2374:
        -: 2375:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
        -: 2376:template <class _InputIterator>
        -: 2377:unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(_InputIterator __first, _InputIterator __last) {
        -: 2378:  insert(__first, __last);
        -: 2379:}
        -: 2380:
        -: 2381:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
        -: 2382:template <class _InputIterator>
        -: 2383:unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        -: 2384:    _InputIterator __first, _InputIterator __last, size_type __n, const hasher& __hf, const key_equal& __eql)
        -: 2385:    : __table_(__hf, __eql) {
        -: 2386:  __table_.__rehash_multi(__n);
        -: 2387:  insert(__first, __last);
        -: 2388:}
        -: 2389:
        -: 2390:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
        -: 2391:template <class _InputIterator>
        -: 2392:unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        -: 2393:    _InputIterator __first,
        -: 2394:    _InputIterator __last,
        -: 2395:    size_type __n,
        -: 2396:    const hasher& __hf,
        -: 2397:    const key_equal& __eql,
        -: 2398:    const allocator_type& __a)
        -: 2399:    : __table_(__hf, __eql, typename __table::allocator_type(__a)) {
        -: 2400:  __table_.__rehash_multi(__n);
        -: 2401:  insert(__first, __last);
        -: 2402:}
        -: 2403:
        -: 2404:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
        -: 2405:inline unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(const allocator_type& __a)
        -: 2406:    : __table_(typename __table::allocator_type(__a)) {}
        -: 2407:
        -: 2408:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
        -: 2409:unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(const unordered_multimap& __u)
        -: 2410:    : __table_(__u.__table_) {
        -: 2411:  __table_.__rehash_multi(__u.bucket_count());
        -: 2412:  insert(__u.begin(), __u.end());
        -: 2413:}
        -: 2414:
        -: 2415:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
        -: 2416:unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        -: 2417:    const unordered_multimap& __u, const allocator_type& __a)
        -: 2418:    : __table_(__u.__table_, typename __table::allocator_type(__a)) {
        -: 2419:  __table_.__rehash_multi(__u.bucket_count());
        -: 2420:  insert(__u.begin(), __u.end());
        -: 2421:}
        -: 2422:
        -: 2423:#ifndef _LIBCPP_CXX03_LANG
        -: 2424:
        -: 2425:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
        -: 2426:inline unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(unordered_multimap&& __u)
        -: 2427:    _NOEXCEPT_(is_nothrow_move_constructible<__table>::value)
        -: 2428:    : __table_(std::move(__u.__table_)) {}
        -: 2429:
        -: 2430:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
        -: 2431:unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        -: 2432:    unordered_multimap&& __u, const allocator_type& __a)
        -: 2433:    : __table_(std::move(__u.__table_), typename __table::allocator_type(__a)) {
        -: 2434:  if (__a != __u.get_allocator()) {
        -: 2435:    iterator __i = __u.begin();
        -: 2436:    while (__u.size() != 0) {
        -: 2437:      __table_.__insert_multi(__u.__table_.remove((__i++).__i_)->__get_value().__move());
        -: 2438:    }
        -: 2439:  }
        -: 2440:}
        -: 2441:
        -: 2442:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
        -: 2443:unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(initializer_list<value_type> __il) {
        -: 2444:  insert(__il.begin(), __il.end());
        -: 2445:}
        -: 2446:
        -: 2447:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
        -: 2448:unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        -: 2449:    initializer_list<value_type> __il, size_type __n, const hasher& __hf, const key_equal& __eql)
        -: 2450:    : __table_(__hf, __eql) {
        -: 2451:  __table_.__rehash_multi(__n);
        -: 2452:  insert(__il.begin(), __il.end());
        -: 2453:}
        -: 2454:
        -: 2455:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
        -: 2456:unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        -: 2457:    initializer_list<value_type> __il,
        -: 2458:    size_type __n,
        -: 2459:    const hasher& __hf,
        -: 2460:    const key_equal& __eql,
        -: 2461:    const allocator_type& __a)
        -: 2462:    : __table_(__hf, __eql, typename __table::allocator_type(__a)) {
        -: 2463:  __table_.__rehash_multi(__n);
        -: 2464:  insert(__il.begin(), __il.end());
        -: 2465:}
        -: 2466:
        -: 2467:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
        -: 2468:inline unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&
        -: 2469:unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::operator=(unordered_multimap&& __u)
        -: 2470:    _NOEXCEPT_(is_nothrow_move_assignable<__table>::value) {
        -: 2471:  __table_ = std::move(__u.__table_);
        -: 2472:  return *this;
        -: 2473:}
        -: 2474:
        -: 2475:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
        -: 2476:inline unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&
        -: 2477:unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::operator=(initializer_list<value_type> __il) {
        -: 2478:  __table_.__assign_multi(__il.begin(), __il.end());
        -: 2479:  return *this;
        -: 2480:}
        -: 2481:
        -: 2482:#endif // _LIBCPP_CXX03_LANG
        -: 2483:
        -: 2484:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
        -: 2485:template <class _InputIterator>
        -: 2486:inline void unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(_InputIterator __first, _InputIterator __last) {
        -: 2487:  for (; __first != __last; ++__first)
        -: 2488:    __table_.__insert_multi(*__first);
        -: 2489:}
        -: 2490:
        -: 2491:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
        -: 2492:inline _LIBCPP_HIDE_FROM_ABI void
        -: 2493:swap(unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x, unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
        -: 2494:    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y))) {
        -: 2495:  __x.swap(__y);
        -: 2496:}
        -: 2497:
        -: 2498:#if _LIBCPP_STD_VER >= 20
        -: 2499:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc, class _Predicate>
        -: 2500:inline _LIBCPP_HIDE_FROM_ABI typename unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type
        -: 2501:erase_if(unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __c, _Predicate __pred) {
        -: 2502:  return std::__libcpp_erase_if_container(__c, __pred);
        -: 2503:}
        -: 2504:#endif
        -: 2505:
        -: 2506:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
        -: 2507:_LIBCPP_HIDE_FROM_ABI bool operator==(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
        -: 2508:                                      const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y) {
        -: 2509:  if (__x.size() != __y.size())
        -: 2510:    return false;
        -: 2511:  typedef typename unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::const_iterator const_iterator;
        -: 2512:  typedef pair<const_iterator, const_iterator> _EqRng;
        -: 2513:  for (const_iterator __i = __x.begin(), __ex = __x.end(); __i != __ex;) {
        -: 2514:    _EqRng __xeq = __x.equal_range(__i->first);
        -: 2515:    _EqRng __yeq = __y.equal_range(__i->first);
        -: 2516:    if (std::distance(__xeq.first, __xeq.second) != std::distance(__yeq.first, __yeq.second) ||
        -: 2517:        !std::is_permutation(__xeq.first, __xeq.second, __yeq.first))
        -: 2518:      return false;
        -: 2519:    __i = __xeq.second;
        -: 2520:  }
        -: 2521:  return true;
        -: 2522:}
        -: 2523:
        -: 2524:#if _LIBCPP_STD_VER <= 17
        -: 2525:
        -: 2526:template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
        -: 2527:inline _LIBCPP_HIDE_FROM_ABI bool operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
        -: 2528:                                             const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y) {
        -: 2529:  return !(__x == __y);
        -: 2530:}
        -: 2531:
        -: 2532:#endif
        -: 2533:
        -: 2534:_LIBCPP_END_NAMESPACE_STD
        -: 2535:
        -: 2536:#if _LIBCPP_STD_VER >= 17
        -: 2537:_LIBCPP_BEGIN_NAMESPACE_STD
        -: 2538:namespace pmr {
        -: 2539:template <class _KeyT, class _ValueT, class _HashT = std::hash<_KeyT>, class _PredT = std::equal_to<_KeyT>>
        -: 2540:using unordered_map _LIBCPP_AVAILABILITY_PMR =
        -: 2541:    std::unordered_map<_KeyT, _ValueT, _HashT, _PredT, polymorphic_allocator<std::pair<const _KeyT, _ValueT>>>;
        -: 2542:
        -: 2543:template <class _KeyT, class _ValueT, class _HashT = std::hash<_KeyT>, class _PredT = std::equal_to<_KeyT>>
        -: 2544:using unordered_multimap _LIBCPP_AVAILABILITY_PMR =
        -: 2545:    std::unordered_multimap<_KeyT, _ValueT, _HashT, _PredT, polymorphic_allocator<std::pair<const _KeyT, _ValueT>>>;
        -: 2546:} // namespace pmr
        -: 2547:_LIBCPP_END_NAMESPACE_STD
        -: 2548:#endif
        -: 2549:
        -: 2550:_LIBCPP_POP_MACROS
        -: 2551:
        -: 2552:#if !defined(_LIBCPP_REMOVE_TRANSITIVE_INCLUDES) && _LIBCPP_STD_VER <= 20
        -: 2553:#  include <algorithm>
        -: 2554:#  include <bit>
        -: 2555:#  include <concepts>
        -: 2556:#  include <cstdlib>
        -: 2557:#  include <iterator>
        -: 2558:#  include <type_traits>
        -: 2559:#endif
        -: 2560:
        -: 2561:#endif // _LIBCPP_UNORDERED_MAP
