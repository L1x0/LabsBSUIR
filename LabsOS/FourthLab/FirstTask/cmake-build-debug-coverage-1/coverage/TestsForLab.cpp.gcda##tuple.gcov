        -:    0:Source:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.0.sdk/usr/include/c++/v1/tuple
        -:    0:Graph:/Users/artemastahov/All_files/styding/LabsBSUIR/LabsOS/FourthLab/FirstTask/cmake-build-debug-coverage-1/CMakeFiles/tests_for_lab.dir/TestsForLab.cpp.gcno
        -:    0:Data:/Users/artemastahov/All_files/styding/LabsBSUIR/LabsOS/FourthLab/FirstTask/cmake-build-debug-coverage-1/CMakeFiles/tests_for_lab.dir/TestsForLab.cpp.gcda
        -:    0:Runs:6
        -:    0:Programs:1
        -:    1:// -*- C++ -*-
        -:    2://===----------------------------------------------------------------------===//
        -:    3://
        -:    4:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    5:// See https://llvm.org/LICENSE.txt for license information.
        -:    6:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    7://
        -:    8://===----------------------------------------------------------------------===//
        -:    9:
        -:   10:#ifndef _LIBCPP_TUPLE
        -:   11:#define _LIBCPP_TUPLE
        -:   12:
        -:   13:// clang-format off
        -:   14:
        -:   15:/*
        -:   16:    tuple synopsis
        -:   17:
        -:   18:namespace std
        -:   19:{
        -:   20:
        -:   21:template <class... T>
        -:   22:class tuple {
        -:   23:public:
        -:   24:    explicit(see-below) constexpr tuple();
        -:   25:    explicit(see-below) tuple(const T&...);  // constexpr in C++14
        -:   26:    template <class... U>
        -:   27:        explicit(see-below) tuple(U&&...);  // constexpr in C++14
        -:   28:    tuple(const tuple&) = default;
        -:   29:    tuple(tuple&&) = default;
        -:   30:
        -:   31:    template<class... UTypes>
        -:   32:        constexpr explicit(see-below) tuple(tuple<UTypes...>&);  // C++23
        -:   33:    template <class... U>
        -:   34:        explicit(see-below) tuple(const tuple<U...>&);  // constexpr in C++14
        -:   35:    template <class... U>
        -:   36:        explicit(see-below) tuple(tuple<U...>&&);  // constexpr in C++14
        -:   37:    template<class... UTypes>
        -:   38:        constexpr explicit(see-below) tuple(const tuple<UTypes...>&&); // C++23
        -:   39:
        -:   40:    template<class U1, class U2>
        -:   41:        constexpr explicit(see-below) tuple(pair<U1, U2>&);  // iff sizeof...(Types) == 2 // C++23
        -:   42:    template <class U1, class U2>
        -:   43:        explicit(see-below) tuple(const pair<U1, U2>&); // iff sizeof...(T) == 2 // constexpr in C++14
        -:   44:    template <class U1, class U2>
        -:   45:        explicit(see-below) tuple(pair<U1, U2>&&); // iff sizeof...(T) == 2  // constexpr in C++14
        -:   46:    template<class U1, class U2>
        -:   47:        constexpr explicit(see-below) tuple(const pair<U1, U2>&&);  // iff sizeof...(Types) == 2 // C++23
        -:   48:
        -:   49:    // allocator-extended constructors
        -:   50:    template <class Alloc>
        -:   51:        tuple(allocator_arg_t, const Alloc& a);
        -:   52:    template <class Alloc>
        -:   53:        explicit(see-below) tuple(allocator_arg_t, const Alloc& a, const T&...);          // constexpr in C++20
        -:   54:    template <class Alloc, class... U>
        -:   55:        explicit(see-below) tuple(allocator_arg_t, const Alloc& a, U&&...);               // constexpr in C++20
        -:   56:    template <class Alloc>
        -:   57:        tuple(allocator_arg_t, const Alloc& a, const tuple&);                             // constexpr in C++20
        -:   58:    template <class Alloc>
        -:   59:        tuple(allocator_arg_t, const Alloc& a, tuple&&);                                  // constexpr in C++20
        -:   60:    template<class Alloc, class... UTypes>
        -:   61:        constexpr explicit(see-below)
        -:   62:          tuple(allocator_arg_t, const Alloc& a, tuple<UTypes...>&);                      // C++23
        -:   63:    template <class Alloc, class... U>
        -:   64:        explicit(see-below) tuple(allocator_arg_t, const Alloc& a, const tuple<U...>&);   // constexpr in C++20
        -:   65:    template <class Alloc, class... U>
        -:   66:        explicit(see-below) tuple(allocator_arg_t, const Alloc& a, tuple<U...>&&);        // constexpr in C++20
        -:   67:    template<class Alloc, class... UTypes>
        -:   68:        constexpr explicit(see-below)
        -:   69:          tuple(allocator_arg_t, const Alloc& a, const tuple<UTypes...>&&);               // C++23
        -:   70:    template<class Alloc, class U1, class U2>
        -:   71:        constexpr explicit(see-below)
        -:   72:          tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&);                          // C++23
        -:   73:    template <class Alloc, class U1, class U2>
        -:   74:        explicit(see-below) tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&);  // constexpr in C++20
        -:   75:    template <class Alloc, class U1, class U2>
        -:   76:        explicit(see-below) tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&&);       // constexpr in C++20
        -:   77:    template<class Alloc, class U1, class U2>
        -:   78:        constexpr explicit(see-below)
        -:   79:          tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&&);                   // C++23
        -:   80:
        -:   81:    tuple& operator=(const tuple&);                                                       // constexpr in C++20
        -:   82:    constexpr const tuple& operator=(const tuple&) const;                                 // C++23
        -:   83:    tuple& operator=(tuple&&) noexcept(is_nothrow_move_assignable_v<T> && ...);           // constexpr in C++20
        -:   84:    constexpr const tuple& operator=(tuple&&) const;                                      // C++23
        -:   85:    template <class... U>
        -:   86:        tuple& operator=(const tuple<U...>&);                                             // constexpr in C++20
        -:   87:    template<class... UTypes>
        -:   88:        constexpr const tuple& operator=(const tuple<UTypes...>&) const;                  // C++23
        -:   89:    template <class... U>
        -:   90:        tuple& operator=(tuple<U...>&&);                                                  // constexpr in C++20
        -:   91:    template<class... UTypes>
        -:   92:        constexpr const tuple& operator=(tuple<UTypes...>&&) const;                       // C++23
        -:   93:    template <class U1, class U2>
        -:   94:        tuple& operator=(const pair<U1, U2>&); // iff sizeof...(T) == 2                   // constexpr in C++20
        -:   95:    template<class U1, class U2>
        -:   96:        constexpr const tuple& operator=(const pair<U1, U2>&) const;   // iff sizeof...(Types) == 2 // C++23
        -:   97:    template <class U1, class U2>
        -:   98:        tuple& operator=(pair<U1, U2>&&); // iff sizeof...(T) == 2                        // constexpr in C++20
        -:   99:    template<class U1, class U2>
        -:  100:        constexpr const tuple& operator=(pair<U1, U2>&&) const;  // iff sizeof...(Types) == 2 // C++23
        -:  101:
        -:  102:    template<class U, size_t N>
        -:  103:        tuple& operator=(array<U, N> const&) // iff sizeof...(T) == N, EXTENSION
        -:  104:    template<class U, size_t N>
        -:  105:        tuple& operator=(array<U, N>&&) // iff sizeof...(T) == N, EXTENSION
        -:  106:
        -:  107:    void swap(tuple&) noexcept(AND(swap(declval<T&>(), declval<T&>())...));               // constexpr in C++20
        -:  108:    constexpr void swap(const tuple&) const noexcept(see-below);                          // C++23
        -:  109:};
        -:  110:
        -:  111:
        -:  112:template<class... TTypes, class... UTypes, template<class> class TQual, template<class> class UQual> // since C++23
        -:  113:  requires requires { typename tuple<common_reference_t<TQual<TTypes>, UQual<UTypes>>...>; }
        -:  114:struct basic_common_reference<tuple<TTypes...>, tuple<UTypes...>, TQual, UQual> {
        -:  115:  using type = tuple<common_reference_t<TQual<TTypes>, UQual<UTypes>>...>;
        -:  116:};
        -:  117:
        -:  118:template<class... TTypes, class... UTypes>                                // since C++23
        -:  119:  requires requires { typename tuple<common_type_t<TTypes, UTypes>...>; }
        -:  120:struct common_type<tuple<TTypes...>, tuple<UTypes...>> {
        -:  121:  using type = tuple<common_type_t<TTypes, UTypes>...>;
        -:  122:};
        -:  123:
        -:  124:template <class ...T>
        -:  125:tuple(T...) -> tuple<T...>;                                         // since C++17
        -:  126:template <class T1, class T2>
        -:  127:tuple(pair<T1, T2>) -> tuple<T1, T2>;                               // since C++17
        -:  128:template <class Alloc, class ...T>
        -:  129:tuple(allocator_arg_t, Alloc, T...) -> tuple<T...>;                 // since C++17
        -:  130:template <class Alloc, class T1, class T2>
        -:  131:tuple(allocator_arg_t, Alloc, pair<T1, T2>) -> tuple<T1, T2>;       // since C++17
        -:  132:template <class Alloc, class ...T>
        -:  133:tuple(allocator_arg_t, Alloc, tuple<T...>) -> tuple<T...>;          // since C++17
        -:  134:
        -:  135:inline constexpr unspecified ignore;
        -:  136:
        -:  137:template <class... T> tuple<V...>  make_tuple(T&&...); // constexpr in C++14
        -:  138:template <class... T> tuple<ATypes...> forward_as_tuple(T&&...) noexcept; // constexpr in C++14
        -:  139:template <class... T> tuple<T&...> tie(T&...) noexcept; // constexpr in C++14
        -:  140:template <class... Tuples> tuple<CTypes...> tuple_cat(Tuples&&... tpls); // constexpr in C++14
        -:  141:
        -:  142:// [tuple.apply], calling a function with a tuple of arguments:
        -:  143:template <class F, class Tuple>
        -:  144:  constexpr decltype(auto) apply(F&& f, Tuple&& t) noexcept(see below);  // C++17 noexcept since C++23
        -:  145:template <class T, class Tuple>
        -:  146:  constexpr T make_from_tuple(Tuple&& t); // C++17
        -:  147:
        -:  148:// 20.4.1.4, tuple helper classes:
        -:  149:template <class T> struct tuple_size; // undefined
        -:  150:template <class... T> struct tuple_size<tuple<T...>>;
        -:  151:template <class T>
        -:  152: inline constexpr size_t tuple_size_v = tuple_size<T>::value; // C++17
        -:  153:template <size_t I, class T> struct tuple_element; // undefined
        -:  154:template <size_t I, class... T> struct tuple_element<I, tuple<T...>>;
        -:  155:template <size_t I, class T>
        -:  156:  using tuple_element_t = typename tuple_element <I, T>::type; // C++14
        -:  157:
        -:  158:// 20.4.1.5, element access:
        -:  159:template <size_t I, class... T>
        -:  160:    typename tuple_element<I, tuple<T...>>::type&
        -:  161:    get(tuple<T...>&) noexcept; // constexpr in C++14
        -:  162:template <size_t I, class... T>
        -:  163:    const typename tuple_element<I, tuple<T...>>::type&
        -:  164:    get(const tuple<T...>&) noexcept; // constexpr in C++14
        -:  165:template <size_t I, class... T>
        -:  166:    typename tuple_element<I, tuple<T...>>::type&&
        -:  167:    get(tuple<T...>&&) noexcept; // constexpr in C++14
        -:  168:template <size_t I, class... T>
        -:  169:    const typename tuple_element<I, tuple<T...>>::type&&
        -:  170:    get(const tuple<T...>&&) noexcept; // constexpr in C++14
        -:  171:
        -:  172:template <class T1, class... T>
        -:  173:    constexpr T1& get(tuple<T...>&) noexcept;  // C++14
        -:  174:template <class T1, class... T>
        -:  175:    constexpr const T1& get(const tuple<T...>&) noexcept;   // C++14
        -:  176:template <class T1, class... T>
        -:  177:    constexpr T1&& get(tuple<T...>&&) noexcept;   // C++14
        -:  178:template <class T1, class... T>
        -:  179:    constexpr const T1&& get(const tuple<T...>&&) noexcept;   // C++14
        -:  180:
        -:  181:// 20.4.1.6, relational operators:
        -:  182:template<class... T, class... U> bool operator==(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14
        -:  183:template<class... T, class... U> bool operator<(const tuple<T...>&, const tuple<U...>&);  // constexpr in C++14, removed in C++20
        -:  184:template<class... T, class... U> bool operator!=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14, removed in C++20
        -:  185:template<class... T, class... U> bool operator>(const tuple<T...>&, const tuple<U...>&);  // constexpr in C++14, removed in C++20
        -:  186:template<class... T, class... U> bool operator<=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14, removed in C++20
        -:  187:template<class... T, class... U> bool operator>=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14, removed in C++20
        -:  188:template<class... T, class... U>
        -:  189:  constexpr common_comparison_category_t<synth-three-way-result<T, U>...>
        -:  190:    operator<=>(const tuple<T...>&, const tuple<U...>&);                                  // since C++20
        -:  191:
        -:  192:template <class... Types, class Alloc>
        -:  193:  struct uses_allocator<tuple<Types...>, Alloc>;
        -:  194:
        -:  195:template <class... Types>
        -:  196:  void
        -:  197:  swap(tuple<Types...>& x, tuple<Types...>& y) noexcept(noexcept(x.swap(y)));
        -:  198:
        -:  199:template <class... Types>
        -:  200:  constexpr void swap(const tuple<Types...>& x, const tuple<Types...>& y) noexcept(see-below);   // C++23
        -:  201:
        -:  202:}  // std
        -:  203:
        -:  204:*/
        -:  205:
        -:  206:// clang-format on
        -:  207:
        -:  208:#include <__assert> // all public C++ headers provide the assertion handler
        -:  209:#include <__compare/common_comparison_category.h>
        -:  210:#include <__compare/synth_three_way.h>
        -:  211:#include <__config>
        -:  212:#include <__functional/invoke.h>
        -:  213:#include <__fwd/array.h>
        -:  214:#include <__fwd/get.h>
        -:  215:#include <__fwd/tuple.h>
        -:  216:#include <__memory/allocator_arg_t.h>
        -:  217:#include <__memory/uses_allocator.h>
        -:  218:#include <__tuple/make_tuple_types.h>
        -:  219:#include <__tuple/sfinae_helpers.h>
        -:  220:#include <__tuple/tuple_element.h>
        -:  221:#include <__tuple/tuple_indices.h>
        -:  222:#include <__tuple/tuple_like_ext.h>
        -:  223:#include <__tuple/tuple_size.h>
        -:  224:#include <__tuple/tuple_types.h>
        -:  225:#include <__type_traits/apply_cv.h>
        -:  226:#include <__type_traits/common_reference.h>
        -:  227:#include <__type_traits/common_type.h>
        -:  228:#include <__type_traits/conditional.h>
        -:  229:#include <__type_traits/conjunction.h>
        -:  230:#include <__type_traits/copy_cvref.h>
        -:  231:#include <__type_traits/disjunction.h>
        -:  232:#include <__type_traits/is_arithmetic.h>
        -:  233:#include <__type_traits/is_assignable.h>
        -:  234:#include <__type_traits/is_constructible.h>
        -:  235:#include <__type_traits/is_convertible.h>
        -:  236:#include <__type_traits/is_copy_assignable.h>
        -:  237:#include <__type_traits/is_copy_constructible.h>
        -:  238:#include <__type_traits/is_default_constructible.h>
        -:  239:#include <__type_traits/is_empty.h>
        -:  240:#include <__type_traits/is_final.h>
        -:  241:#include <__type_traits/is_implicitly_default_constructible.h>
        -:  242:#include <__type_traits/is_move_assignable.h>
        -:  243:#include <__type_traits/is_move_constructible.h>
        -:  244:#include <__type_traits/is_nothrow_assignable.h>
        -:  245:#include <__type_traits/is_nothrow_constructible.h>
        -:  246:#include <__type_traits/is_nothrow_copy_assignable.h>
        -:  247:#include <__type_traits/is_nothrow_copy_constructible.h>
        -:  248:#include <__type_traits/is_nothrow_default_constructible.h>
        -:  249:#include <__type_traits/is_nothrow_move_assignable.h>
        -:  250:#include <__type_traits/is_reference.h>
        -:  251:#include <__type_traits/is_same.h>
        -:  252:#include <__type_traits/is_swappable.h>
        -:  253:#include <__type_traits/lazy.h>
        -:  254:#include <__type_traits/maybe_const.h>
        -:  255:#include <__type_traits/nat.h>
        -:  256:#include <__type_traits/negation.h>
        -:  257:#include <__type_traits/remove_cvref.h>
        -:  258:#include <__type_traits/remove_reference.h>
        -:  259:#include <__type_traits/unwrap_ref.h>
        -:  260:#include <__utility/forward.h>
        -:  261:#include <__utility/integer_sequence.h>
        -:  262:#include <__utility/move.h>
        -:  263:#include <__utility/pair.h>
        -:  264:#include <__utility/piecewise_construct.h>
        -:  265:#include <__utility/swap.h>
        -:  266:#include <cstddef>
        -:  267:#include <version>
        -:  268:
        -:  269:// standard-mandated includes
        -:  270:
        -:  271:// [tuple.syn]
        -:  272:#include <compare>
        -:  273:
        -:  274:#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
        -:  275:#  pragma GCC system_header
        -:  276:#endif
        -:  277:
        -:  278:_LIBCPP_PUSH_MACROS
        -:  279:#include <__undef_macros>
        -:  280:
        -:  281:_LIBCPP_BEGIN_NAMESPACE_STD
        -:  282:
        -:  283:#ifndef _LIBCPP_CXX03_LANG
        -:  284:
        -:  285:// __tuple_leaf
        -:  286:
        -:  287:template <size_t _Ip, class _Hp, bool = is_empty<_Hp>::value && !__libcpp_is_final<_Hp>::value >
        -:  288:class __tuple_leaf;
        -:  289:
        -:  290:template <size_t _Ip, class _Hp, bool _Ep>
        -:  291:inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 void
        -:  292:swap(__tuple_leaf<_Ip, _Hp, _Ep>& __x, __tuple_leaf<_Ip, _Hp, _Ep>& __y)
        -:  293:    _NOEXCEPT_(__is_nothrow_swappable<_Hp>::value) {
        -:  294:  swap(__x.get(), __y.get());
        -:  295:}
        -:  296:
        -:  297:template <size_t _Ip, class _Hp, bool _Ep>
        -:  298:_LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 void
        -:  299:swap(const __tuple_leaf<_Ip, _Hp, _Ep>& __x, const __tuple_leaf<_Ip, _Hp, _Ep>& __y)
        -:  300:    _NOEXCEPT_(__is_nothrow_swappable<const _Hp>::value) {
        -:  301:  swap(__x.get(), __y.get());
        -:  302:}
        -:  303:
        -:  304:template <size_t _Ip, class _Hp, bool>
        -:  305:class __tuple_leaf {
        -:  306:  _Hp __value_;
        -:  307:
        -:  308:  template <class _Tp>
        -:  309:  static _LIBCPP_HIDE_FROM_ABI constexpr bool __can_bind_reference() {
        -:  310:#  if __has_keyword(__reference_binds_to_temporary)
        -:  311:    return !__reference_binds_to_temporary(_Hp, _Tp);
        -:  312:#  else
        -:  313:    return true;
        -:  314:#  endif
        -:  315:  }
        -:  316:
        -:  317:  _LIBCPP_CONSTEXPR_SINCE_CXX14 __tuple_leaf& operator=(const __tuple_leaf&);
        -:  318:
        -:  319:public:
        -:  320:  _LIBCPP_HIDE_FROM_ABI constexpr __tuple_leaf() _NOEXCEPT_(is_nothrow_default_constructible<_Hp>::value) : __value_() {
        -:  321:    static_assert(!is_reference<_Hp>::value, "Attempted to default construct a reference element in a tuple");
        -:  322:  }
        -:  323:
        -:  324:  template <class _Alloc>
        -:  325:  _LIBCPP_HIDE_FROM_ABI constexpr __tuple_leaf(integral_constant<int, 0>, const _Alloc&) : __value_() {
        -:  326:    static_assert(!is_reference<_Hp>::value, "Attempted to default construct a reference element in a tuple");
        -:  327:  }
        -:  328:
        -:  329:  template <class _Alloc>
        -:  330:  _LIBCPP_HIDE_FROM_ABI constexpr __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)
        -:  331:      : __value_(allocator_arg_t(), __a) {
        -:  332:    static_assert(!is_reference<_Hp>::value, "Attempted to default construct a reference element in a tuple");
        -:  333:  }
        -:  334:
        -:  335:  template <class _Alloc>
        -:  336:  _LIBCPP_HIDE_FROM_ABI constexpr __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a) : __value_(__a) {
        -:  337:    static_assert(!is_reference<_Hp>::value, "Attempted to default construct a reference element in a tuple");
        -:  338:  }
        -:  339:
        -:  340:  template <class _Tp,
        -:  341:            class = __enable_if_t<
        -:  342:                _And< _IsNotSame<__remove_cvref_t<_Tp>, __tuple_leaf>, is_constructible<_Hp, _Tp> >::value > >
function _ZNSt3__112__tuple_leafILm0ERKPvLb0EEC2B8ne180100IS3_vEEOT_ called 7 returned 100% blocks executed 100%
        7:  343:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 explicit __tuple_leaf(_Tp&& __t)
        -:  344:      _NOEXCEPT_((is_nothrow_constructible<_Hp, _Tp>::value))
        7:  345:      : __value_(std::forward<_Tp>(__t)) {
        -:  346:    static_assert(__can_bind_reference<_Tp&&>(),
        -:  347:                  "Attempted construction of reference element binds to a temporary whose lifetime has ended");
        7:  348:  }
        7:  348-block  0
        -:  349:
        -:  350:  template <class _Tp, class _Alloc>
        -:  351:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 explicit __tuple_leaf(
        -:  352:      integral_constant<int, 0>, const _Alloc&, _Tp&& __t)
        -:  353:      : __value_(std::forward<_Tp>(__t)) {
        -:  354:    static_assert(__can_bind_reference<_Tp&&>(),
        -:  355:                  "Attempted construction of reference element binds to a temporary whose lifetime has ended");
        -:  356:  }
        -:  357:
        -:  358:  template <class _Tp, class _Alloc>
        -:  359:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 explicit __tuple_leaf(
        -:  360:      integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)
        -:  361:      : __value_(allocator_arg_t(), __a, std::forward<_Tp>(__t)) {
        -:  362:    static_assert(!is_reference<_Hp>::value, "Attempted to uses-allocator construct a reference element in a tuple");
        -:  363:  }
        -:  364:
        -:  365:  template <class _Tp, class _Alloc>
        -:  366:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 explicit __tuple_leaf(
        -:  367:      integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)
        -:  368:      : __value_(std::forward<_Tp>(__t), __a) {
        -:  369:    static_assert(!is_reference<_Hp>::value, "Attempted to uses-allocator construct a reference element in a tuple");
        -:  370:  }
        -:  371:
        -:  372:  _LIBCPP_HIDE_FROM_ABI __tuple_leaf(const __tuple_leaf& __t) = default;
        -:  373:  _LIBCPP_HIDE_FROM_ABI __tuple_leaf(__tuple_leaf&& __t)      = default;
        -:  374:
        -:  375:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 int swap(__tuple_leaf& __t)
        -:  376:      _NOEXCEPT_(__is_nothrow_swappable<__tuple_leaf>::value) {
        -:  377:    std::swap(*this, __t);
        -:  378:    return 0;
        -:  379:  }
        -:  380:
        -:  381:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 int swap(const __tuple_leaf& __t) const
        -:  382:      _NOEXCEPT_(__is_nothrow_swappable<const __tuple_leaf>::value) {
        -:  383:    std::swap(*this, __t);
        -:  384:    return 0;
        -:  385:  }
        -:  386:
function _ZNSt3__112__tuple_leafILm0ERKPvLb0EE3getB8ne180100Ev called 7 returned 100% blocks executed 100%
        7:  387:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 _Hp& get() _NOEXCEPT { return __value_; }
        7:  387-block  0
        -:  388:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 const _Hp& get() const _NOEXCEPT { return __value_; }
        -:  389:};
        -:  390:
        -:  391:template <size_t _Ip, class _Hp>
        -:  392:class __tuple_leaf<_Ip, _Hp, true> : private _Hp {
        -:  393:  _LIBCPP_CONSTEXPR_SINCE_CXX14 __tuple_leaf& operator=(const __tuple_leaf&);
        -:  394:
        -:  395:public:
        -:  396:  _LIBCPP_HIDE_FROM_ABI constexpr __tuple_leaf() _NOEXCEPT_(is_nothrow_default_constructible<_Hp>::value) {}
        -:  397:
        -:  398:  template <class _Alloc>
        -:  399:  _LIBCPP_HIDE_FROM_ABI constexpr __tuple_leaf(integral_constant<int, 0>, const _Alloc&) {}
        -:  400:
        -:  401:  template <class _Alloc>
        -:  402:  _LIBCPP_HIDE_FROM_ABI constexpr __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)
        -:  403:      : _Hp(allocator_arg_t(), __a) {}
        -:  404:
        -:  405:  template <class _Alloc>
        -:  406:  _LIBCPP_HIDE_FROM_ABI constexpr __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a) : _Hp(__a) {}
        -:  407:
        -:  408:  template <class _Tp,
        -:  409:            class = __enable_if_t<
        -:  410:                _And< _IsNotSame<__remove_cvref_t<_Tp>, __tuple_leaf>, is_constructible<_Hp, _Tp> >::value > >
        -:  411:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 explicit __tuple_leaf(_Tp&& __t)
        -:  412:      _NOEXCEPT_((is_nothrow_constructible<_Hp, _Tp>::value))
        -:  413:      : _Hp(std::forward<_Tp>(__t)) {}
        -:  414:
        -:  415:  template <class _Tp, class _Alloc>
        -:  416:  _LIBCPP_HIDE_FROM_ABI constexpr explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)
        -:  417:      : _Hp(std::forward<_Tp>(__t)) {}
        -:  418:
        -:  419:  template <class _Tp, class _Alloc>
        -:  420:  _LIBCPP_HIDE_FROM_ABI constexpr explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)
        -:  421:      : _Hp(allocator_arg_t(), __a, std::forward<_Tp>(__t)) {}
        -:  422:
        -:  423:  template <class _Tp, class _Alloc>
        -:  424:  _LIBCPP_HIDE_FROM_ABI constexpr explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)
        -:  425:      : _Hp(std::forward<_Tp>(__t), __a) {}
        -:  426:
        -:  427:  __tuple_leaf(__tuple_leaf const&) = default;
        -:  428:  __tuple_leaf(__tuple_leaf&&)      = default;
        -:  429:
        -:  430:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 int swap(__tuple_leaf& __t)
        -:  431:      _NOEXCEPT_(__is_nothrow_swappable<__tuple_leaf>::value) {
        -:  432:    std::swap(*this, __t);
        -:  433:    return 0;
        -:  434:  }
        -:  435:
        -:  436:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 int swap(const __tuple_leaf& __rhs) const
        -:  437:      _NOEXCEPT_(__is_nothrow_swappable<const __tuple_leaf>::value) {
        -:  438:    std::swap(*this, __rhs);
        -:  439:    return 0;
        -:  440:  }
        -:  441:
        -:  442:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 _Hp& get() _NOEXCEPT { return static_cast<_Hp&>(*this); }
        -:  443:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 const _Hp& get() const _NOEXCEPT {
        -:  444:    return static_cast<const _Hp&>(*this);
        -:  445:  }
        -:  446:};
        -:  447:
        -:  448:template <class... _Tp>
        -:  449:_LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 void __swallow(_Tp&&...) _NOEXCEPT {}
        -:  450:
        -:  451:template <class _Tp>
        -:  452:struct __all_default_constructible;
        -:  453:
        -:  454:template <class... _Tp>
        -:  455:struct __all_default_constructible<__tuple_types<_Tp...>> : __all<is_default_constructible<_Tp>::value...> {};
        -:  456:
        -:  457:// __tuple_impl
        -:  458:
        -:  459:template <class _Indx, class... _Tp>
        -:  460:struct __tuple_impl;
        -:  461:
        -:  462:template <size_t... _Indx, class... _Tp>
        -:  463:struct _LIBCPP_DECLSPEC_EMPTY_BASES __tuple_impl<__tuple_indices<_Indx...>, _Tp...>
        -:  464:    : public __tuple_leaf<_Indx, _Tp>... {
        -:  465:  _LIBCPP_HIDE_FROM_ABI constexpr __tuple_impl()
        -:  466:      _NOEXCEPT_(__all<is_nothrow_default_constructible<_Tp>::value...>::value) {}
        -:  467:
        -:  468:  template <size_t... _Uf, class... _Tf, size_t... _Ul, class... _Tl, class... _Up>
function _ZNSt3__112__tuple_implINS_15__tuple_indicesIJLm0EEEEJRKPvEEC1B8ne180100IJLm0EEJS5_EJEJEJS5_EEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENS9_IJDpT2_EEEDpOT3_ called 7 returned 100% blocks executed 100%
function _ZNSt3__112__tuple_implINS_15__tuple_indicesIJLm0EEEEJRKPvEEC2B8ne180100IJLm0EEJS5_EJEJEJS5_EEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENS9_IJDpT2_EEEDpOT3_ called 7 returned 100% blocks executed 100%
       14:  469:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 explicit __tuple_impl(
        -:  470:      __tuple_indices<_Uf...>, __tuple_types<_Tf...>, __tuple_indices<_Ul...>, __tuple_types<_Tl...>, _Up&&... __u)
        -:  471:      _NOEXCEPT_((__all<is_nothrow_constructible<_Tf, _Up>::value...>::value &&
        -:  472:                  __all<is_nothrow_default_constructible<_Tl>::value...>::value))
       14:  473:      : __tuple_leaf<_Uf, _Tf>(std::forward<_Up>(__u))..., __tuple_leaf<_Ul, _Tl>()... {}
        7:  473-block  0
        7:  473-block  1
        -:  474:
        -:  475:  template <class _Alloc, size_t... _Uf, class... _Tf, size_t... _Ul, class... _Tl, class... _Up>
        -:  476:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 explicit __tuple_impl(
        -:  477:      allocator_arg_t,
        -:  478:      const _Alloc& __a,
        -:  479:      __tuple_indices<_Uf...>,
        -:  480:      __tuple_types<_Tf...>,
        -:  481:      __tuple_indices<_Ul...>,
        -:  482:      __tuple_types<_Tl...>,
        -:  483:      _Up&&... __u)
        -:  484:      : __tuple_leaf<_Uf, _Tf>(__uses_alloc_ctor<_Tf, _Alloc, _Up>(), __a, std::forward<_Up>(__u))...,
        -:  485:        __tuple_leaf<_Ul, _Tl>(__uses_alloc_ctor<_Tl, _Alloc>(), __a)... {}
        -:  486:
        -:  487:  template <class _Tuple, class = __enable_if_t<__tuple_constructible<_Tuple, tuple<_Tp...> >::value> >
        -:  488:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 __tuple_impl(_Tuple&& __t) _NOEXCEPT_(
        -:  489:      (__all<is_nothrow_constructible<
        -:  490:           _Tp,
        -:  491:           typename tuple_element<_Indx, typename __make_tuple_types<_Tuple>::type>::type>::value...>::value))
        -:  492:      : __tuple_leaf<_Indx, _Tp>(
        -:  493:            std::forward<typename tuple_element<_Indx, typename __make_tuple_types<_Tuple>::type>::type>(
        -:  494:                std::get<_Indx>(__t)))... {}
        -:  495:
        -:  496:  template <class _Alloc, class _Tuple, class = __enable_if_t<__tuple_constructible<_Tuple, tuple<_Tp...> >::value> >
        -:  497:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 __tuple_impl(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)
        -:  498:      : __tuple_leaf<_Indx, _Tp>(
        -:  499:            __uses_alloc_ctor<_Tp,
        -:  500:                              _Alloc,
        -:  501:                              typename tuple_element<_Indx, typename __make_tuple_types<_Tuple>::type>::type>(),
        -:  502:            __a,
        -:  503:            std::forward<typename tuple_element<_Indx, typename __make_tuple_types<_Tuple>::type>::type>(
        -:  504:                std::get<_Indx>(__t)))... {}
        -:  505:
        -:  506:  __tuple_impl(const __tuple_impl&) = default;
        -:  507:  __tuple_impl(__tuple_impl&&)      = default;
        -:  508:
        -:  509:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 void swap(__tuple_impl& __t)
        -:  510:      _NOEXCEPT_(__all<__is_nothrow_swappable<_Tp>::value...>::value) {
        -:  511:    std::__swallow(__tuple_leaf<_Indx, _Tp>::swap(static_cast<__tuple_leaf<_Indx, _Tp>&>(__t))...);
        -:  512:  }
        -:  513:
        -:  514:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 void swap(const __tuple_impl& __t) const
        -:  515:      _NOEXCEPT_(__all<__is_nothrow_swappable<const _Tp>::value...>::value) {
        -:  516:    std::__swallow(__tuple_leaf<_Indx, _Tp>::swap(static_cast<const __tuple_leaf<_Indx, _Tp>&>(__t))...);
        -:  517:  }
        -:  518:};
        -:  519:
        -:  520:template <class _Dest, class _Source, size_t... _Np>
        -:  521:_LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 void
        -:  522:__memberwise_copy_assign(_Dest& __dest, _Source const& __source, __tuple_indices<_Np...>) {
        -:  523:  std::__swallow(((std::get<_Np>(__dest) = std::get<_Np>(__source)), void(), 0)...);
        -:  524:}
        -:  525:
        -:  526:template <class _Dest, class _Source, class... _Up, size_t... _Np>
        -:  527:_LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 void
        -:  528:__memberwise_forward_assign(_Dest& __dest, _Source&& __source, __tuple_types<_Up...>, __tuple_indices<_Np...>) {
        -:  529:  std::__swallow(((std::get<_Np>(__dest) = std::forward<_Up>(std::get<_Np>(__source))), void(), 0)...);
        -:  530:}
        -:  531:
        -:  532:template <class... _Tp>
        -:  533:class _LIBCPP_TEMPLATE_VIS tuple {
        -:  534:  typedef __tuple_impl<typename __make_tuple_indices<sizeof...(_Tp)>::type, _Tp...> _BaseT;
        -:  535:
        -:  536:  _BaseT __base_;
        -:  537:
        -:  538:  template <size_t _Jp, class... _Up>
        -:  539:  friend _LIBCPP_CONSTEXPR_SINCE_CXX14 typename tuple_element<_Jp, tuple<_Up...> >::type& get(tuple<_Up...>&) _NOEXCEPT;
        -:  540:  template <size_t _Jp, class... _Up>
        -:  541:  friend _LIBCPP_CONSTEXPR_SINCE_CXX14 const typename tuple_element<_Jp, tuple<_Up...> >::type&
        -:  542:  get(const tuple<_Up...>&) _NOEXCEPT;
        -:  543:  template <size_t _Jp, class... _Up>
        -:  544:  friend _LIBCPP_CONSTEXPR_SINCE_CXX14 typename tuple_element<_Jp, tuple<_Up...> >::type&&
        -:  545:  get(tuple<_Up...>&&) _NOEXCEPT;
        -:  546:  template <size_t _Jp, class... _Up>
        -:  547:  friend _LIBCPP_CONSTEXPR_SINCE_CXX14 const typename tuple_element<_Jp, tuple<_Up...> >::type&&
        -:  548:  get(const tuple<_Up...>&&) _NOEXCEPT;
        -:  549:
        -:  550:public:
        -:  551:  // [tuple.cnstr]
        -:  552:
        -:  553:  _LIBCPP_DIAGNOSTIC_PUSH
        -:  554:  _LIBCPP_CLANG_DIAGNOSTIC_IGNORED("-Wc++20-extensions")
        -:  555:  _LIBCPP_GCC_DIAGNOSTIC_IGNORED("-Wc++20-extensions")
        -:  556:
        -:  557:  // tuple() constructors (including allocator_arg_t variants)
        -:  558:  template <template <class...> class _IsImpDefault                = __is_implicitly_default_constructible,
        -:  559:            template <class...> class _IsDefault                   = is_default_constructible,
        -:  560:            __enable_if_t< _And< _IsDefault<_Tp>... >::value, int> = 0>
        -:  561:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR explicit(_Not<_Lazy<_And, _IsImpDefault<_Tp>...> >::value) tuple()
        -:  562:      _NOEXCEPT_(_And<is_nothrow_default_constructible<_Tp>...>::value) {}
        -:  563:
        -:  564:  template <class _Alloc,
        -:  565:            template <class...> class _IsImpDefault                = __is_implicitly_default_constructible,
        -:  566:            template <class...> class _IsDefault                   = is_default_constructible,
        -:  567:            __enable_if_t< _And< _IsDefault<_Tp>... >::value, int> = 0>
        -:  568:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 explicit(_Not<_Lazy<_And, _IsImpDefault<_Tp>...> >::value)
        -:  569:      tuple(allocator_arg_t, _Alloc const& __a)
        -:  570:      : __base_(allocator_arg_t(),
        -:  571:                __a,
        -:  572:                __tuple_indices<>(),
        -:  573:                __tuple_types<>(),
        -:  574:                typename __make_tuple_indices<sizeof...(_Tp), 0>::type(),
        -:  575:                __tuple_types<_Tp...>()) {}
        -:  576:
        -:  577:  // tuple(const T&...) constructors (including allocator_arg_t variants)
        -:  578:  template <template <class...> class _And = _And,
        -:  579:            __enable_if_t< _And< _BoolConstant<sizeof...(_Tp) >= 1>, is_copy_constructible<_Tp>... >::value, int> = 0>
        -:  580:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 explicit(
function _ZNSt3__15tupleIJRKPvEEC1B8ne180100INS_4_AndELi0EEES3_ called 7 returned 100% blocks executed 100%
function _ZNSt3__15tupleIJRKPvEEC2B8ne180100INS_4_AndELi0EEES3_ called 7 returned 100% blocks executed 100%
       14:  581:      _Not<_Lazy<_And, is_convertible<const _Tp&, _Tp>...> >::value) tuple(const _Tp&... __t)
        -:  582:      _NOEXCEPT_(_And<is_nothrow_copy_constructible<_Tp>...>::value)
       14:  583:      : __base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),
        -:  584:                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
        -:  585:                typename __make_tuple_indices<0>::type(),
        -:  586:                typename __make_tuple_types<tuple, 0>::type(),
       21:  587:                __t...) {}
        7:  587-block  0
        7:  587-block  1
        7:  587-block  2
        -:  588:
        -:  589:  template <class _Alloc,
        -:  590:            template <class...> class _And = _And,
        -:  591:            __enable_if_t< _And< _BoolConstant<sizeof...(_Tp) >= 1>, is_copy_constructible<_Tp>... >::value, int> = 0>
        -:  592:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 explicit(
        -:  593:      _Not<_Lazy<_And, is_convertible<const _Tp&, _Tp>...> >::value)
        -:  594:      tuple(allocator_arg_t, const _Alloc& __a, const _Tp&... __t)
        -:  595:      : __base_(allocator_arg_t(),
        -:  596:                __a,
        -:  597:                typename __make_tuple_indices<sizeof...(_Tp)>::type(),
        -:  598:                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
        -:  599:                typename __make_tuple_indices<0>::type(),
        -:  600:                typename __make_tuple_types<tuple, 0>::type(),
        -:  601:                __t...) {}
        -:  602:
        -:  603:  // tuple(U&& ...) constructors (including allocator_arg_t variants)
        -:  604:  template <class... _Up>
        -:  605:  struct _IsThisTuple : false_type {};
        -:  606:  template <class _Up>
        -:  607:  struct _IsThisTuple<_Up> : is_same<__remove_cvref_t<_Up>, tuple> {};
        -:  608:
        -:  609:  template <class... _Up>
        -:  610:  struct _EnableUTypesCtor
        -:  611:      : _And< _BoolConstant<sizeof...(_Tp) >= 1>,
        -:  612:              _Not<_IsThisTuple<_Up...> >, // extension to allow mis-behaved user constructors
        -:  613:              is_constructible<_Tp, _Up>... > {};
        -:  614:
        -:  615:  template <class... _Up,
        -:  616:            __enable_if_t< _And< _BoolConstant<sizeof...(_Up) == sizeof...(_Tp)>, _EnableUTypesCtor<_Up...> >::value,
        -:  617:                           int> = 0>
        -:  618:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 explicit(_Not<_Lazy<_And, is_convertible<_Up, _Tp>...> >::value)
        -:  619:      tuple(_Up&&... __u) _NOEXCEPT_((_And<is_nothrow_constructible<_Tp, _Up>...>::value))
        -:  620:      : __base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),
        -:  621:                typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
        -:  622:                typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
        -:  623:                typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
        -:  624:                std::forward<_Up>(__u)...) {}
        -:  625:
        -:  626:  template <class _Alloc,
        -:  627:            class... _Up,
        -:  628:            __enable_if_t< _And< _BoolConstant<sizeof...(_Up) == sizeof...(_Tp)>, _EnableUTypesCtor<_Up...> >::value,
        -:  629:                           int> = 0>
        -:  630:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 explicit(_Not<_Lazy<_And, is_convertible<_Up, _Tp>...> >::value)
        -:  631:      tuple(allocator_arg_t, const _Alloc& __a, _Up&&... __u)
        -:  632:      : __base_(allocator_arg_t(),
        -:  633:                __a,
        -:  634:                typename __make_tuple_indices<sizeof...(_Up)>::type(),
        -:  635:                typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
        -:  636:                typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
        -:  637:                typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
        -:  638:                std::forward<_Up>(__u)...) {}
        -:  639:
        -:  640:  // Copy and move constructors (including the allocator_arg_t variants)
        -:  641:  tuple(const tuple&) = default;
        -:  642:  tuple(tuple&&)      = default;
        -:  643:
        -:  644:  template <class _Alloc,
        -:  645:            template <class...> class _And                                  = _And,
        -:  646:            __enable_if_t< _And<is_copy_constructible<_Tp>...>::value, int> = 0>
        -:  647:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 tuple(allocator_arg_t, const _Alloc& __alloc, const tuple& __t)
        -:  648:      : __base_(allocator_arg_t(), __alloc, __t) {}
        -:  649:
        -:  650:  template <class _Alloc,
        -:  651:            template <class...> class _And                                  = _And,
        -:  652:            __enable_if_t< _And<is_move_constructible<_Tp>...>::value, int> = 0>
        -:  653:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 tuple(allocator_arg_t, const _Alloc& __alloc, tuple&& __t)
        -:  654:      : __base_(allocator_arg_t(), __alloc, std::move(__t)) {}
        -:  655:
        -:  656:  // tuple(const tuple<U...>&) constructors (including allocator_arg_t variants)
        -:  657:
        -:  658:  template <class _OtherTuple, class _DecayedOtherTuple = __remove_cvref_t<_OtherTuple>, class = void>
        -:  659:  struct _EnableCtorFromUTypesTuple : false_type {};
        -:  660:
        -:  661:  template <class _OtherTuple, class... _Up>
        -:  662:  struct _EnableCtorFromUTypesTuple<
        -:  663:      _OtherTuple,
        -:  664:      tuple<_Up...>,
        -:  665:      // the length of the packs needs to checked first otherwise the 2 packs cannot be expanded simultaneously below
        -:  666:      __enable_if_t<sizeof...(_Up) == sizeof...(_Tp)>>
        -:  667:      : _And<
        -:  668:            // the two conditions below are not in spec. The purpose is to disable the UTypes Ctor when copy/move Ctor
        -:  669:            // can work. Otherwise, is_constructible can trigger hard error in those cases
        -:  670:            // https://godbolt.org/z/M94cGdKcE
        -:  671:            _Not<is_same<_OtherTuple, const tuple&> >,
        -:  672:            _Not<is_same<_OtherTuple, tuple&&> >,
        -:  673:            is_constructible<_Tp, __copy_cvref_t<_OtherTuple, _Up> >...,
        -:  674:            _Lazy<_Or,
        -:  675:                  _BoolConstant<sizeof...(_Tp) != 1>,
        -:  676:                  // _Tp and _Up are 1-element packs - the pack expansions look
        -:  677:                  // weird to avoid tripping up the type traits in degenerate cases
        -:  678:                  _Lazy<_And,
        -:  679:                        _Not<is_same<_Tp, _Up> >...,
        -:  680:                        _Not<is_convertible<_OtherTuple, _Tp> >...,
        -:  681:                        _Not<is_constructible<_Tp, _OtherTuple> >... > > > {};
        -:  682:
        -:  683:  template <class... _Up, __enable_if_t< _And< _EnableCtorFromUTypesTuple<const tuple<_Up...>&> >::value, int> = 0>
        -:  684:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 explicit(
        -:  685:      _Not<_Lazy<_And, is_convertible<const _Up&, _Tp>...> >::value) tuple(const tuple<_Up...>& __t)
        -:  686:      _NOEXCEPT_((_And<is_nothrow_constructible<_Tp, const _Up&>...>::value))
        -:  687:      : __base_(__t) {}
        -:  688:
        -:  689:  template <class... _Up,
        -:  690:            class _Alloc,
        -:  691:            __enable_if_t< _And< _EnableCtorFromUTypesTuple<const tuple<_Up...>&> >::value, int> = 0>
        -:  692:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 explicit(
        -:  693:      _Not<_Lazy<_And, is_convertible<const _Up&, _Tp>...> >::value)
        -:  694:      tuple(allocator_arg_t, const _Alloc& __a, const tuple<_Up...>& __t)
        -:  695:      : __base_(allocator_arg_t(), __a, __t) {}
        -:  696:
        -:  697:#  if _LIBCPP_STD_VER >= 23
        -:  698:  // tuple(tuple<U...>&) constructors (including allocator_arg_t variants)
        -:  699:
        -:  700:  template <class... _Up, enable_if_t< _EnableCtorFromUTypesTuple<tuple<_Up...>&>::value>* = nullptr>
        -:  701:  _LIBCPP_HIDE_FROM_ABI constexpr explicit(!_Lazy<_And, is_convertible<_Up&, _Tp>...>::value) tuple(tuple<_Up...>& __t)
        -:  702:      : __base_(__t) {}
        -:  703:
        -:  704:  template <class _Alloc, class... _Up, enable_if_t< _EnableCtorFromUTypesTuple<tuple<_Up...>&>::value>* = nullptr>
        -:  705:  _LIBCPP_HIDE_FROM_ABI constexpr explicit(!_Lazy<_And, is_convertible<_Up&, _Tp>...>::value)
        -:  706:      tuple(allocator_arg_t, const _Alloc& __alloc, tuple<_Up...>& __t)
        -:  707:      : __base_(allocator_arg_t(), __alloc, __t) {}
        -:  708:#  endif // _LIBCPP_STD_VER >= 23
        -:  709:
        -:  710:  // tuple(tuple<U...>&&) constructors (including allocator_arg_t variants)
        -:  711:  template <class... _Up, __enable_if_t< _And< _EnableCtorFromUTypesTuple<tuple<_Up...>&&> >::value, int> = 0>
        -:  712:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 explicit(_Not<_Lazy<_And, is_convertible<_Up, _Tp>...> >::value)
        -:  713:      tuple(tuple<_Up...>&& __t) _NOEXCEPT_((_And<is_nothrow_constructible<_Tp, _Up>...>::value))
        -:  714:      : __base_(std::move(__t)) {}
        -:  715:
        -:  716:  template <class _Alloc,
        -:  717:            class... _Up,
        -:  718:            __enable_if_t< _And< _EnableCtorFromUTypesTuple<tuple<_Up...>&&> >::value, int> = 0>
        -:  719:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 explicit(_Not<_Lazy<_And, is_convertible<_Up, _Tp>...> >::value)
        -:  720:      tuple(allocator_arg_t, const _Alloc& __a, tuple<_Up...>&& __t)
        -:  721:      : __base_(allocator_arg_t(), __a, std::move(__t)) {}
        -:  722:
        -:  723:#  if _LIBCPP_STD_VER >= 23
        -:  724:  // tuple(const tuple<U...>&&) constructors (including allocator_arg_t variants)
        -:  725:
        -:  726:  template <class... _Up, enable_if_t< _EnableCtorFromUTypesTuple<const tuple<_Up...>&&>::value>* = nullptr>
        -:  727:  _LIBCPP_HIDE_FROM_ABI constexpr explicit(!_Lazy<_And, is_convertible<const _Up&&, _Tp>...>::value)
        -:  728:      tuple(const tuple<_Up...>&& __t)
        -:  729:      : __base_(std::move(__t)) {}
        -:  730:
        -:  731:  template <class _Alloc,
        -:  732:            class... _Up,
        -:  733:            enable_if_t< _EnableCtorFromUTypesTuple<const tuple<_Up...>&&>::value>* = nullptr>
        -:  734:  _LIBCPP_HIDE_FROM_ABI constexpr explicit(!_Lazy<_And, is_convertible<const _Up&&, _Tp>...>::value)
        -:  735:      tuple(allocator_arg_t, const _Alloc& __alloc, const tuple<_Up...>&& __t)
        -:  736:      : __base_(allocator_arg_t(), __alloc, std::move(__t)) {}
        -:  737:#  endif // _LIBCPP_STD_VER >= 23
        -:  738:
        -:  739:  // tuple(const pair<U1, U2>&) constructors (including allocator_arg_t variants)
        -:  740:
        -:  741:  template <template <class...> class _Pred,
        -:  742:            class _Pair,
        -:  743:            class _DecayedPair = __remove_cvref_t<_Pair>,
        -:  744:            class _Tuple       = tuple>
        -:  745:  struct _CtorPredicateFromPair : false_type {};
        -:  746:
        -:  747:  template <template <class...> class _Pred, class _Pair, class _Up1, class _Up2, class _Tp1, class _Tp2>
        -:  748:  struct _CtorPredicateFromPair<_Pred, _Pair, pair<_Up1, _Up2>, tuple<_Tp1, _Tp2> >
        -:  749:      : _And< _Pred<_Tp1, __copy_cvref_t<_Pair, _Up1> >, _Pred<_Tp2, __copy_cvref_t<_Pair, _Up2> > > {};
        -:  750:
        -:  751:  template <class _Pair>
        -:  752:  struct _EnableCtorFromPair : _CtorPredicateFromPair<is_constructible, _Pair> {};
        -:  753:
        -:  754:  template <class _Pair>
        -:  755:  struct _NothrowConstructibleFromPair : _CtorPredicateFromPair<is_nothrow_constructible, _Pair> {};
        -:  756:
        -:  757:  template <class _Pair, class _DecayedPair = __remove_cvref_t<_Pair>, class _Tuple = tuple>
        -:  758:  struct _BothImplicitlyConvertible : false_type {};
        -:  759:
        -:  760:  template <class _Pair, class _Up1, class _Up2, class _Tp1, class _Tp2>
        -:  761:  struct _BothImplicitlyConvertible<_Pair, pair<_Up1, _Up2>, tuple<_Tp1, _Tp2> >
        -:  762:      : _And< is_convertible<__copy_cvref_t<_Pair, _Up1>, _Tp1>, is_convertible<__copy_cvref_t<_Pair, _Up2>, _Tp2> > {};
        -:  763:
        -:  764:  template <class _Up1,
        -:  765:            class _Up2,
        -:  766:            template <class...> class _And                                                   = _And,
        -:  767:            __enable_if_t< _And< _EnableCtorFromPair<const pair<_Up1, _Up2>&> >::value, int> = 0>
        -:  768:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 explicit(
        -:  769:      _Not<_BothImplicitlyConvertible<const pair<_Up1, _Up2>&> >::value) tuple(const pair<_Up1, _Up2>& __p)
        -:  770:      _NOEXCEPT_((_NothrowConstructibleFromPair<const pair<_Up1, _Up2>&>::value))
        -:  771:      : __base_(__p) {}
        -:  772:
        -:  773:  template <class _Alloc,
        -:  774:            class _Up1,
        -:  775:            class _Up2,
        -:  776:            template <class...> class _And                                                   = _And,
        -:  777:            __enable_if_t< _And< _EnableCtorFromPair<const pair<_Up1, _Up2>&> >::value, int> = 0>
        -:  778:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 explicit(
        -:  779:      _Not<_BothImplicitlyConvertible<const pair<_Up1, _Up2>&> >::value)
        -:  780:      tuple(allocator_arg_t, const _Alloc& __a, const pair<_Up1, _Up2>& __p)
        -:  781:      : __base_(allocator_arg_t(), __a, __p) {}
        -:  782:
        -:  783:#  if _LIBCPP_STD_VER >= 23
        -:  784:  // tuple(pair<U1, U2>&) constructors (including allocator_arg_t variants)
        -:  785:
        -:  786:  template <class _U1, class _U2, enable_if_t< _EnableCtorFromPair<pair<_U1, _U2>&>::value>* = nullptr>
        -:  787:  _LIBCPP_HIDE_FROM_ABI constexpr explicit(!_BothImplicitlyConvertible<pair<_U1, _U2>&>::value)
        -:  788:      tuple(pair<_U1, _U2>& __p)
        -:  789:      : __base_(__p) {}
        -:  790:
        -:  791:  template <class _Alloc,
        -:  792:            class _U1,
        -:  793:            class _U2,
        -:  794:            enable_if_t< _EnableCtorFromPair<std::pair<_U1, _U2>&>::value>* = nullptr>
        -:  795:  _LIBCPP_HIDE_FROM_ABI constexpr explicit(!_BothImplicitlyConvertible<pair<_U1, _U2>&>::value)
        -:  796:      tuple(allocator_arg_t, const _Alloc& __alloc, pair<_U1, _U2>& __p)
        -:  797:      : __base_(allocator_arg_t(), __alloc, __p) {}
        -:  798:#  endif
        -:  799:
        -:  800:  // tuple(pair<U1, U2>&&) constructors (including allocator_arg_t variants)
        -:  801:
        -:  802:  template <class _Up1,
        -:  803:            class _Up2,
        -:  804:            template <class...> class _And                                              = _And,
        -:  805:            __enable_if_t< _And< _EnableCtorFromPair<pair<_Up1, _Up2>&&> >::value, int> = 0>
        -:  806:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 explicit(
        -:  807:      _Not<_BothImplicitlyConvertible<pair<_Up1, _Up2>&&> >::value) tuple(pair<_Up1, _Up2>&& __p)
        -:  808:      _NOEXCEPT_((_NothrowConstructibleFromPair<pair<_Up1, _Up2>&&>::value))
        -:  809:      : __base_(std::move(__p)) {}
        -:  810:
        -:  811:  template <class _Alloc,
        -:  812:            class _Up1,
        -:  813:            class _Up2,
        -:  814:            template <class...> class _And                                              = _And,
        -:  815:            __enable_if_t< _And< _EnableCtorFromPair<pair<_Up1, _Up2>&&> >::value, int> = 0>
        -:  816:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 explicit(
        -:  817:      _Not<_BothImplicitlyConvertible<pair<_Up1, _Up2>&&> >::value)
        -:  818:      tuple(allocator_arg_t, const _Alloc& __a, pair<_Up1, _Up2>&& __p)
        -:  819:      : __base_(allocator_arg_t(), __a, std::move(__p)) {}
        -:  820:
        -:  821:#  if _LIBCPP_STD_VER >= 23
        -:  822:  // tuple(const pair<U1, U2>&&) constructors (including allocator_arg_t variants)
        -:  823:
        -:  824:  template <class _U1, class _U2, enable_if_t< _EnableCtorFromPair<const pair<_U1, _U2>&&>::value>* = nullptr>
        -:  825:  _LIBCPP_HIDE_FROM_ABI constexpr explicit(!_BothImplicitlyConvertible<const pair<_U1, _U2>&&>::value)
        -:  826:      tuple(const pair<_U1, _U2>&& __p)
        -:  827:      : __base_(std::move(__p)) {}
        -:  828:
        -:  829:  template <class _Alloc,
        -:  830:            class _U1,
        -:  831:            class _U2,
        -:  832:            enable_if_t< _EnableCtorFromPair<const pair<_U1, _U2>&&>::value>* = nullptr>
        -:  833:  _LIBCPP_HIDE_FROM_ABI constexpr explicit(!_BothImplicitlyConvertible<const pair<_U1, _U2>&&>::value)
        -:  834:      tuple(allocator_arg_t, const _Alloc& __alloc, const pair<_U1, _U2>&& __p)
        -:  835:      : __base_(allocator_arg_t(), __alloc, std::move(__p)) {}
        -:  836:#  endif // _LIBCPP_STD_VER >= 23
        -:  837:
        -:  838:  _LIBCPP_DIAGNOSTIC_POP
        -:  839:
        -:  840:  // [tuple.assign]
        -:  841:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 tuple&
        -:  842:  operator=(_If<_And<is_copy_assignable<_Tp>...>::value, tuple, __nat> const& __tuple)
        -:  843:      _NOEXCEPT_((_And<is_nothrow_copy_assignable<_Tp>...>::value)) {
        -:  844:    std::__memberwise_copy_assign(*this, __tuple, typename __make_tuple_indices<sizeof...(_Tp)>::type());
        -:  845:    return *this;
        -:  846:  }
        -:  847:
        -:  848:#  if _LIBCPP_STD_VER >= 23
        -:  849:  _LIBCPP_HIDE_FROM_ABI constexpr const tuple& operator=(tuple const& __tuple) const
        -:  850:    requires(_And<is_copy_assignable<const _Tp>...>::value)
        -:  851:  {
        -:  852:    std::__memberwise_copy_assign(*this, __tuple, typename __make_tuple_indices<sizeof...(_Tp)>::type());
        -:  853:    return *this;
        -:  854:  }
        -:  855:
        -:  856:  _LIBCPP_HIDE_FROM_ABI constexpr const tuple& operator=(tuple&& __tuple) const
        -:  857:    requires(_And<is_assignable<const _Tp&, _Tp>...>::value)
        -:  858:  {
        -:  859:    std::__memberwise_forward_assign(
        -:  860:        *this, std::move(__tuple), __tuple_types<_Tp...>(), typename __make_tuple_indices<sizeof...(_Tp)>::type());
        -:  861:    return *this;
        -:  862:  }
        -:  863:#  endif // _LIBCPP_STD_VER >= 23
        -:  864:
        -:  865:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 tuple&
        -:  866:  operator=(_If<_And<is_move_assignable<_Tp>...>::value, tuple, __nat>&& __tuple)
        -:  867:      _NOEXCEPT_((_And<is_nothrow_move_assignable<_Tp>...>::value)) {
        -:  868:    std::__memberwise_forward_assign(
        -:  869:        *this, std::move(__tuple), __tuple_types<_Tp...>(), typename __make_tuple_indices<sizeof...(_Tp)>::type());
        -:  870:    return *this;
        -:  871:  }
        -:  872:
        -:  873:  template <
        -:  874:      class... _Up,
        -:  875:      __enable_if_t< _And< _BoolConstant<sizeof...(_Tp) == sizeof...(_Up)>, is_assignable<_Tp&, _Up const&>... >::value,
        -:  876:                     int> = 0>
        -:  877:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 tuple& operator=(tuple<_Up...> const& __tuple)
        -:  878:      _NOEXCEPT_((_And<is_nothrow_assignable<_Tp&, _Up const&>...>::value)) {
        -:  879:    std::__memberwise_copy_assign(*this, __tuple, typename __make_tuple_indices<sizeof...(_Tp)>::type());
        -:  880:    return *this;
        -:  881:  }
        -:  882:
        -:  883:  template <class... _Up,
        -:  884:            __enable_if_t< _And< _BoolConstant<sizeof...(_Tp) == sizeof...(_Up)>, is_assignable<_Tp&, _Up>... >::value,
        -:  885:                           int> = 0>
        -:  886:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 tuple& operator=(tuple<_Up...>&& __tuple)
        -:  887:      _NOEXCEPT_((_And<is_nothrow_assignable<_Tp&, _Up>...>::value)) {
        -:  888:    std::__memberwise_forward_assign(
        -:  889:        *this, std::move(__tuple), __tuple_types<_Up...>(), typename __make_tuple_indices<sizeof...(_Tp)>::type());
        -:  890:    return *this;
        -:  891:  }
        -:  892:
        -:  893:#  if _LIBCPP_STD_VER >= 23
        -:  894:  template <class... _UTypes,
        -:  895:            enable_if_t< _And<_BoolConstant<sizeof...(_Tp) == sizeof...(_UTypes)>,
        -:  896:                              is_assignable<const _Tp&, const _UTypes&>...>::value>* = nullptr>
        -:  897:  _LIBCPP_HIDE_FROM_ABI constexpr const tuple& operator=(const tuple<_UTypes...>& __u) const {
        -:  898:    std::__memberwise_copy_assign(*this, __u, typename __make_tuple_indices<sizeof...(_Tp)>::type());
        -:  899:    return *this;
        -:  900:  }
        -:  901:
        -:  902:  template <class... _UTypes,
        -:  903:            enable_if_t< _And<_BoolConstant<sizeof...(_Tp) == sizeof...(_UTypes)>,
        -:  904:                              is_assignable<const _Tp&, _UTypes>...>::value>* = nullptr>
        -:  905:  _LIBCPP_HIDE_FROM_ABI constexpr const tuple& operator=(tuple<_UTypes...>&& __u) const {
        -:  906:    std::__memberwise_forward_assign(
        -:  907:        *this, __u, __tuple_types<_UTypes...>(), typename __make_tuple_indices<sizeof...(_Tp)>::type());
        -:  908:    return *this;
        -:  909:  }
        -:  910:#  endif // _LIBCPP_STD_VER >= 23
        -:  911:
        -:  912:  template <template <class...> class _Pred,
        -:  913:            bool _Const,
        -:  914:            class _Pair,
        -:  915:            class _DecayedPair = __remove_cvref_t<_Pair>,
        -:  916:            class _Tuple       = tuple>
        -:  917:  struct _AssignPredicateFromPair : false_type {};
        -:  918:
        -:  919:  template <template <class...> class _Pred, bool _Const, class _Pair, class _Up1, class _Up2, class _Tp1, class _Tp2>
        -:  920:  struct _AssignPredicateFromPair<_Pred, _Const, _Pair, pair<_Up1, _Up2>, tuple<_Tp1, _Tp2> >
        -:  921:      : _And<_Pred<__maybe_const<_Const, _Tp1>&, __copy_cvref_t<_Pair, _Up1> >,
        -:  922:             _Pred<__maybe_const<_Const, _Tp2>&, __copy_cvref_t<_Pair, _Up2> > > {};
        -:  923:
        -:  924:  template <bool _Const, class _Pair>
        -:  925:  struct _EnableAssignFromPair : _AssignPredicateFromPair<is_assignable, _Const, _Pair> {};
        -:  926:
        -:  927:  template <bool _Const, class _Pair>
        -:  928:  struct _NothrowAssignFromPair : _AssignPredicateFromPair<is_nothrow_assignable, _Const, _Pair> {};
        -:  929:
        -:  930:#  if _LIBCPP_STD_VER >= 23
        -:  931:  template <class _U1, class _U2, enable_if_t< _EnableAssignFromPair<true, const pair<_U1, _U2>&>::value>* = nullptr>
        -:  932:  _LIBCPP_HIDE_FROM_ABI constexpr const tuple& operator=(const pair<_U1, _U2>& __pair) const
        -:  933:      noexcept(_NothrowAssignFromPair<true, const pair<_U1, _U2>&>::value) {
        -:  934:    std::get<0>(*this) = __pair.first;
        -:  935:    std::get<1>(*this) = __pair.second;
        -:  936:    return *this;
        -:  937:  }
        -:  938:
        -:  939:  template <class _U1, class _U2, enable_if_t< _EnableAssignFromPair<true, pair<_U1, _U2>&&>::value>* = nullptr>
        -:  940:  _LIBCPP_HIDE_FROM_ABI constexpr const tuple& operator=(pair<_U1, _U2>&& __pair) const
        -:  941:      noexcept(_NothrowAssignFromPair<true, pair<_U1, _U2>&&>::value) {
        -:  942:    std::get<0>(*this) = std::move(__pair.first);
        -:  943:    std::get<1>(*this) = std::move(__pair.second);
        -:  944:    return *this;
        -:  945:  }
        -:  946:#  endif // _LIBCPP_STD_VER >= 23
        -:  947:
        -:  948:  template <class _Up1,
        -:  949:            class _Up2,
        -:  950:            __enable_if_t< _EnableAssignFromPair<false, pair<_Up1, _Up2> const&>::value, int> = 0>
        -:  951:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 tuple& operator=(pair<_Up1, _Up2> const& __pair)
        -:  952:      _NOEXCEPT_((_NothrowAssignFromPair<false, pair<_Up1, _Up2> const&>::value)) {
        -:  953:    std::get<0>(*this) = __pair.first;
        -:  954:    std::get<1>(*this) = __pair.second;
        -:  955:    return *this;
        -:  956:  }
        -:  957:
        -:  958:  template <class _Up1, class _Up2, __enable_if_t< _EnableAssignFromPair<false, pair<_Up1, _Up2>&&>::value, int> = 0>
        -:  959:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 tuple& operator=(pair<_Up1, _Up2>&& __pair)
        -:  960:      _NOEXCEPT_((_NothrowAssignFromPair<false, pair<_Up1, _Up2>&&>::value)) {
        -:  961:    std::get<0>(*this) = std::forward<_Up1>(__pair.first);
        -:  962:    std::get<1>(*this) = std::forward<_Up2>(__pair.second);
        -:  963:    return *this;
        -:  964:  }
        -:  965:
        -:  966:  // EXTENSION
        -:  967:  template <
        -:  968:      class _Up,
        -:  969:      size_t _Np,
        -:  970:      class = __enable_if_t< _And< _BoolConstant<_Np == sizeof...(_Tp)>, is_assignable<_Tp&, _Up const&>... >::value > >
        -:  971:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 tuple& operator=(array<_Up, _Np> const& __array)
        -:  972:      _NOEXCEPT_((_And<is_nothrow_assignable<_Tp&, _Up const&>...>::value)) {
        -:  973:    std::__memberwise_copy_assign(*this, __array, typename __make_tuple_indices<sizeof...(_Tp)>::type());
        -:  974:    return *this;
        -:  975:  }
        -:  976:
        -:  977:  // EXTENSION
        -:  978:  template <class _Up,
        -:  979:            size_t _Np,
        -:  980:            class = void,
        -:  981:            class = __enable_if_t< _And< _BoolConstant<_Np == sizeof...(_Tp)>, is_assignable<_Tp&, _Up>... >::value > >
        -:  982:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 tuple& operator=(array<_Up, _Np>&& __array)
        -:  983:      _NOEXCEPT_((_And<is_nothrow_assignable<_Tp&, _Up>...>::value)) {
        -:  984:    std::__memberwise_forward_assign(
        -:  985:        *this,
        -:  986:        std::move(__array),
        -:  987:        __tuple_types<_If<true, _Up, _Tp>...>(),
        -:  988:        typename __make_tuple_indices<sizeof...(_Tp)>::type());
        -:  989:    return *this;
        -:  990:  }
        -:  991:
        -:  992:  // [tuple.swap]
        -:  993:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 void swap(tuple& __t)
        -:  994:      _NOEXCEPT_(__all<__is_nothrow_swappable<_Tp>::value...>::value) {
        -:  995:    __base_.swap(__t.__base_);
        -:  996:  }
        -:  997:
        -:  998:#  if _LIBCPP_STD_VER >= 23
        -:  999:  _LIBCPP_HIDE_FROM_ABI constexpr void swap(const tuple& __t) const
        -: 1000:      noexcept(__all<is_nothrow_swappable_v<const _Tp&>...>::value) {
        -: 1001:    __base_.swap(__t.__base_);
        -: 1002:  }
        -: 1003:#  endif // _LIBCPP_STD_VER >= 23
        -: 1004:};
        -: 1005:
        -: 1006:template <>
        -: 1007:class _LIBCPP_TEMPLATE_VIS tuple<> {
        -: 1008:public:
        -: 1009:  constexpr tuple() _NOEXCEPT = default;
        -: 1010:  template <class _Alloc>
        -: 1011:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 tuple(allocator_arg_t, const _Alloc&) _NOEXCEPT {}
        -: 1012:  template <class _Alloc>
        -: 1013:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 tuple(allocator_arg_t, const _Alloc&, const tuple&) _NOEXCEPT {}
        -: 1014:  template <class _Up>
        -: 1015:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 tuple(array<_Up, 0>) _NOEXCEPT {}
        -: 1016:  template <class _Alloc, class _Up>
        -: 1017:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 tuple(allocator_arg_t, const _Alloc&, array<_Up, 0>) _NOEXCEPT {}
        -: 1018:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 void swap(tuple&) _NOEXCEPT {}
        -: 1019:#  if _LIBCPP_STD_VER >= 23
        -: 1020:  _LIBCPP_HIDE_FROM_ABI constexpr void swap(const tuple&) const noexcept {}
        -: 1021:#  endif
        -: 1022:};
        -: 1023:
        -: 1024:#  if _LIBCPP_STD_VER >= 23
        -: 1025:template <class... _TTypes, class... _UTypes, template <class> class _TQual, template <class> class _UQual>
        -: 1026:  requires requires { typename tuple<common_reference_t<_TQual<_TTypes>, _UQual<_UTypes>>...>; }
        -: 1027:struct basic_common_reference<tuple<_TTypes...>, tuple<_UTypes...>, _TQual, _UQual> {
        -: 1028:  using type = tuple<common_reference_t<_TQual<_TTypes>, _UQual<_UTypes>>...>;
        -: 1029:};
        -: 1030:
        -: 1031:template <class... _TTypes, class... _UTypes>
        -: 1032:  requires requires { typename tuple<common_type_t<_TTypes, _UTypes>...>; }
        -: 1033:struct common_type<tuple<_TTypes...>, tuple<_UTypes...>> {
        -: 1034:  using type = tuple<common_type_t<_TTypes, _UTypes>...>;
        -: 1035:};
        -: 1036:#  endif // _LIBCPP_STD_VER >= 23
        -: 1037:
        -: 1038:#  if _LIBCPP_STD_VER >= 17
        -: 1039:template <class... _Tp>
        -: 1040:tuple(_Tp...) -> tuple<_Tp...>;
        -: 1041:template <class _Tp1, class _Tp2>
        -: 1042:tuple(pair<_Tp1, _Tp2>) -> tuple<_Tp1, _Tp2>;
        -: 1043:template <class _Alloc, class... _Tp>
        -: 1044:tuple(allocator_arg_t, _Alloc, _Tp...) -> tuple<_Tp...>;
        -: 1045:template <class _Alloc, class _Tp1, class _Tp2>
        -: 1046:tuple(allocator_arg_t, _Alloc, pair<_Tp1, _Tp2>) -> tuple<_Tp1, _Tp2>;
        -: 1047:template <class _Alloc, class... _Tp>
        -: 1048:tuple(allocator_arg_t, _Alloc, tuple<_Tp...>) -> tuple<_Tp...>;
        -: 1049:#  endif
        -: 1050:
        -: 1051:template <class... _Tp, __enable_if_t<__all<__is_swappable<_Tp>::value...>::value, int> = 0>
        -: 1052:inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 void swap(tuple<_Tp...>& __t, tuple<_Tp...>& __u)
        -: 1053:    _NOEXCEPT_(__all<__is_nothrow_swappable<_Tp>::value...>::value) {
        -: 1054:  __t.swap(__u);
        -: 1055:}
        -: 1056:
        -: 1057:#  if _LIBCPP_STD_VER >= 23
        -: 1058:template <class... _Tp>
        -: 1059:_LIBCPP_HIDE_FROM_ABI constexpr enable_if_t<__all<is_swappable_v<const _Tp>...>::value, void>
        -: 1060:swap(const tuple<_Tp...>& __lhs,
        -: 1061:     const tuple<_Tp...>& __rhs) noexcept(__all<is_nothrow_swappable_v<const _Tp>...>::value) {
        -: 1062:  __lhs.swap(__rhs);
        -: 1063:}
        -: 1064:#  endif
        -: 1065:
        -: 1066:// get
        -: 1067:
        -: 1068:template <size_t _Ip, class... _Tp>
        -: 1069:inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 typename tuple_element<_Ip, tuple<_Tp...> >::type&
function _ZNSt3__13getB8ne180100ILm0EJRKPvEEERNS_13tuple_elementIXT_ENS_5tupleIJDpT0_EEEE4typeERS8_ called 7 returned 100% blocks executed 100%
        7: 1070:get(tuple<_Tp...>& __t) _NOEXCEPT {
        -: 1071:  typedef _LIBCPP_NODEBUG typename tuple_element<_Ip, tuple<_Tp...> >::type type;
        7: 1072:  return static_cast<__tuple_leaf<_Ip, type>&>(__t.__base_).get();
        7: 1072-block  0
        -: 1073:}
        -: 1074:
        -: 1075:template <size_t _Ip, class... _Tp>
        -: 1076:inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 const typename tuple_element<_Ip, tuple<_Tp...> >::type&
        -: 1077:get(const tuple<_Tp...>& __t) _NOEXCEPT {
        -: 1078:  typedef _LIBCPP_NODEBUG typename tuple_element<_Ip, tuple<_Tp...> >::type type;
        -: 1079:  return static_cast<const __tuple_leaf<_Ip, type>&>(__t.__base_).get();
        -: 1080:}
        -: 1081:
        -: 1082:template <size_t _Ip, class... _Tp>
        -: 1083:inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 typename tuple_element<_Ip, tuple<_Tp...> >::type&&
        -: 1084:get(tuple<_Tp...>&& __t) _NOEXCEPT {
        -: 1085:  typedef _LIBCPP_NODEBUG typename tuple_element<_Ip, tuple<_Tp...> >::type type;
        -: 1086:  return static_cast<type&&>(static_cast<__tuple_leaf<_Ip, type>&&>(__t.__base_).get());
        -: 1087:}
        -: 1088:
        -: 1089:template <size_t _Ip, class... _Tp>
        -: 1090:inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 const typename tuple_element<_Ip, tuple<_Tp...> >::type&&
        -: 1091:get(const tuple<_Tp...>&& __t) _NOEXCEPT {
        -: 1092:  typedef _LIBCPP_NODEBUG typename tuple_element<_Ip, tuple<_Tp...> >::type type;
        -: 1093:  return static_cast<const type&&>(static_cast<const __tuple_leaf<_Ip, type>&&>(__t.__base_).get());
        -: 1094:}
        -: 1095:
        -: 1096:#  if _LIBCPP_STD_VER >= 14
        -: 1097:
        -: 1098:namespace __find_detail {
        -: 1099:
        -: 1100:static constexpr size_t __not_found = static_cast<size_t>(-1);
        -: 1101:static constexpr size_t __ambiguous = __not_found - 1;
        -: 1102:
        -: 1103:inline _LIBCPP_HIDE_FROM_ABI constexpr size_t __find_idx_return(size_t __curr_i, size_t __res, bool __matches) {
        -: 1104:  return !__matches ? __res : (__res == __not_found ? __curr_i : __ambiguous);
        -: 1105:}
        -: 1106:
        -: 1107:template <size_t _Nx>
        -: 1108:inline _LIBCPP_HIDE_FROM_ABI constexpr size_t __find_idx(size_t __i, const bool (&__matches)[_Nx]) {
        -: 1109:  return __i == _Nx
        -: 1110:           ? __not_found
        -: 1111:           : __find_detail::__find_idx_return(__i, __find_detail::__find_idx(__i + 1, __matches), __matches[__i]);
        -: 1112:}
        -: 1113:
        -: 1114:template <class _T1, class... _Args>
        -: 1115:struct __find_exactly_one_checked {
        -: 1116:  static constexpr bool __matches[sizeof...(_Args)] = {is_same<_T1, _Args>::value...};
        -: 1117:  static constexpr size_t value                     = __find_detail::__find_idx(0, __matches);
        -: 1118:  static_assert(value != __not_found, "type not found in type list");
        -: 1119:  static_assert(value != __ambiguous, "type occurs more than once in type list");
        -: 1120:};
        -: 1121:
        -: 1122:template <class _T1>
        -: 1123:struct __find_exactly_one_checked<_T1> {
        -: 1124:  static_assert(!is_same<_T1, _T1>::value, "type not in empty type list");
        -: 1125:};
        -: 1126:
        -: 1127:} // namespace __find_detail
        -: 1128:
        -: 1129:template <typename _T1, typename... _Args>
        -: 1130:struct __find_exactly_one_t : public __find_detail::__find_exactly_one_checked<_T1, _Args...> {};
        -: 1131:
        -: 1132:template <class _T1, class... _Args>
        -: 1133:inline _LIBCPP_HIDE_FROM_ABI constexpr _T1& get(tuple<_Args...>& __tup) noexcept {
        -: 1134:  return std::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);
        -: 1135:}
        -: 1136:
        -: 1137:template <class _T1, class... _Args>
        -: 1138:inline _LIBCPP_HIDE_FROM_ABI constexpr _T1 const& get(tuple<_Args...> const& __tup) noexcept {
        -: 1139:  return std::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);
        -: 1140:}
        -: 1141:
        -: 1142:template <class _T1, class... _Args>
        -: 1143:inline _LIBCPP_HIDE_FROM_ABI constexpr _T1&& get(tuple<_Args...>&& __tup) noexcept {
        -: 1144:  return std::get<__find_exactly_one_t<_T1, _Args...>::value>(std::move(__tup));
        -: 1145:}
        -: 1146:
        -: 1147:template <class _T1, class... _Args>
        -: 1148:inline _LIBCPP_HIDE_FROM_ABI constexpr _T1 const&& get(tuple<_Args...> const&& __tup) noexcept {
        -: 1149:  return std::get<__find_exactly_one_t<_T1, _Args...>::value>(std::move(__tup));
        -: 1150:}
        -: 1151:
        -: 1152:#  endif
        -: 1153:
        -: 1154:// tie
        -: 1155:
        -: 1156:template <class... _Tp>
        -: 1157:inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 tuple<_Tp&...> tie(_Tp&... __t) _NOEXCEPT {
        -: 1158:  return tuple<_Tp&...>(__t...);
        -: 1159:}
        -: 1160:
        -: 1161:template <class _Up>
        -: 1162:struct __ignore_t {
        -: 1163:  template <class _Tp>
        -: 1164:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 const __ignore_t& operator=(_Tp&&) const {
        -: 1165:    return *this;
        -: 1166:  }
        -: 1167:};
        -: 1168:
        -: 1169:#  if _LIBCPP_STD_VER >= 17
        -: 1170:inline constexpr __ignore_t<unsigned char> ignore = __ignore_t<unsigned char>();
        -: 1171:#  else
        -: 1172:namespace {
        -: 1173:constexpr __ignore_t<unsigned char> ignore = __ignore_t<unsigned char>();
        -: 1174:} // namespace
        -: 1175:#  endif
        -: 1176:
        -: 1177:template <class... _Tp>
        -: 1178:inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 tuple<typename __unwrap_ref_decay<_Tp>::type...>
        -: 1179:make_tuple(_Tp&&... __t) {
        -: 1180:  return tuple<typename __unwrap_ref_decay<_Tp>::type...>(std::forward<_Tp>(__t)...);
        -: 1181:}
        -: 1182:
        -: 1183:template <class... _Tp>
function _ZNSt3__116forward_as_tupleB8ne180100IJRKPvEEENS_5tupleIJDpOT_EEES7_ called 7 returned 100% blocks executed 100%
function _ZNSt3__116forward_as_tupleB8ne180100IJEEENS_5tupleIJDpOT_EEES4_ called 7 returned 100% blocks executed 100%
       14: 1184:inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 tuple<_Tp&&...> forward_as_tuple(_Tp&&... __t) _NOEXCEPT {
       14: 1185:  return tuple<_Tp&&...>(std::forward<_Tp>(__t)...);
        7: 1185-block  0
        7: 1185-block  1
        -: 1186:}
        -: 1187:
        -: 1188:template <size_t _Ip>
        -: 1189:struct __tuple_equal {
        -: 1190:  template <class _Tp, class _Up>
        -: 1191:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 bool operator()(const _Tp& __x, const _Up& __y) {
        -: 1192:    return __tuple_equal<_Ip - 1>()(__x, __y) && std::get<_Ip - 1>(__x) == std::get<_Ip - 1>(__y);
        -: 1193:  }
        -: 1194:};
        -: 1195:
        -: 1196:template <>
        -: 1197:struct __tuple_equal<0> {
        -: 1198:  template <class _Tp, class _Up>
        -: 1199:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 bool operator()(const _Tp&, const _Up&) {
        -: 1200:    return true;
        -: 1201:  }
        -: 1202:};
        -: 1203:
        -: 1204:template <class... _Tp, class... _Up>
        -: 1205:inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 bool
        -: 1206:operator==(const tuple<_Tp...>& __x, const tuple<_Up...>& __y) {
        -: 1207:  static_assert(sizeof...(_Tp) == sizeof...(_Up), "Can't compare tuples of different sizes");
        -: 1208:  return __tuple_equal<sizeof...(_Tp)>()(__x, __y);
        -: 1209:}
        -: 1210:
        -: 1211:#  if _LIBCPP_STD_VER >= 20
        -: 1212:
        -: 1213:// operator<=>
        -: 1214:
        -: 1215:template <class... _Tp, class... _Up, size_t... _Is>
        -: 1216:_LIBCPP_HIDE_FROM_ABI constexpr auto
        -: 1217:__tuple_compare_three_way(const tuple<_Tp...>& __x, const tuple<_Up...>& __y, index_sequence<_Is...>) {
        -: 1218:  common_comparison_category_t<__synth_three_way_result<_Tp, _Up>...> __result = strong_ordering::equal;
        -: 1219:  static_cast<void>(
        -: 1220:      ((__result = std::__synth_three_way(std::get<_Is>(__x), std::get<_Is>(__y)), __result != 0) || ...));
        -: 1221:  return __result;
        -: 1222:}
        -: 1223:
        -: 1224:template <class... _Tp, class... _Up>
        -: 1225:  requires(sizeof...(_Tp) == sizeof...(_Up))
        -: 1226:_LIBCPP_HIDE_FROM_ABI constexpr common_comparison_category_t<__synth_three_way_result<_Tp, _Up>...>
        -: 1227:operator<=>(const tuple<_Tp...>& __x, const tuple<_Up...>& __y) {
        -: 1228:  return std::__tuple_compare_three_way(__x, __y, index_sequence_for<_Tp...>{});
        -: 1229:}
        -: 1230:
        -: 1231:#  else // _LIBCPP_STD_VER >= 20
        -: 1232:
        -: 1233:template <class... _Tp, class... _Up>
        -: 1234:inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 bool
        -: 1235:operator!=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y) {
        -: 1236:  return !(__x == __y);
        -: 1237:}
        -: 1238:
        -: 1239:template <size_t _Ip>
        -: 1240:struct __tuple_less {
        -: 1241:  template <class _Tp, class _Up>
        -: 1242:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 bool operator()(const _Tp& __x, const _Up& __y) {
        -: 1243:    const size_t __idx = tuple_size<_Tp>::value - _Ip;
        -: 1244:    if (std::get<__idx>(__x) < std::get<__idx>(__y))
        -: 1245:      return true;
        -: 1246:    if (std::get<__idx>(__y) < std::get<__idx>(__x))
        -: 1247:      return false;
        -: 1248:    return __tuple_less<_Ip - 1>()(__x, __y);
        -: 1249:  }
        -: 1250:};
        -: 1251:
        -: 1252:template <>
        -: 1253:struct __tuple_less<0> {
        -: 1254:  template <class _Tp, class _Up>
        -: 1255:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 bool operator()(const _Tp&, const _Up&) {
        -: 1256:    return false;
        -: 1257:  }
        -: 1258:};
        -: 1259:
        -: 1260:template <class... _Tp, class... _Up>
        -: 1261:inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 bool
        -: 1262:operator<(const tuple<_Tp...>& __x, const tuple<_Up...>& __y) {
        -: 1263:  static_assert(sizeof...(_Tp) == sizeof...(_Up), "Can't compare tuples of different sizes");
        -: 1264:  return __tuple_less<sizeof...(_Tp)>()(__x, __y);
        -: 1265:}
        -: 1266:
        -: 1267:template <class... _Tp, class... _Up>
        -: 1268:inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 bool
        -: 1269:operator>(const tuple<_Tp...>& __x, const tuple<_Up...>& __y) {
        -: 1270:  return __y < __x;
        -: 1271:}
        -: 1272:
        -: 1273:template <class... _Tp, class... _Up>
        -: 1274:inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 bool
        -: 1275:operator>=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y) {
        -: 1276:  return !(__x < __y);
        -: 1277:}
        -: 1278:
        -: 1279:template <class... _Tp, class... _Up>
        -: 1280:inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 bool
        -: 1281:operator<=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y) {
        -: 1282:  return !(__y < __x);
        -: 1283:}
        -: 1284:
        -: 1285:#  endif // _LIBCPP_STD_VER >= 20
        -: 1286:
        -: 1287:// tuple_cat
        -: 1288:
        -: 1289:template <class _Tp, class _Up>
        -: 1290:struct __tuple_cat_type;
        -: 1291:
        -: 1292:template <class... _Ttypes, class... _Utypes>
        -: 1293:struct __tuple_cat_type<tuple<_Ttypes...>, __tuple_types<_Utypes...> > {
        -: 1294:  typedef _LIBCPP_NODEBUG tuple<_Ttypes..., _Utypes...> type;
        -: 1295:};
        -: 1296:
        -: 1297:template <class _ResultTuple, bool _Is_Tuple0TupleLike, class... _Tuples>
        -: 1298:struct __tuple_cat_return_1 {};
        -: 1299:
        -: 1300:template <class... _Types, class _Tuple0>
        -: 1301:struct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0> {
        -: 1302:  using type _LIBCPP_NODEBUG =
        -: 1303:      typename __tuple_cat_type< tuple<_Types...>,
        -: 1304:                                 typename __make_tuple_types<__remove_cvref_t<_Tuple0> >::type >::type;
        -: 1305:};
        -: 1306:
        -: 1307:template <class... _Types, class _Tuple0, class _Tuple1, class... _Tuples>
        -: 1308:struct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0, _Tuple1, _Tuples...>
        -: 1309:    : public __tuple_cat_return_1<
        -: 1310:          typename __tuple_cat_type< tuple<_Types...>,
        -: 1311:                                     typename __make_tuple_types<__remove_cvref_t<_Tuple0> >::type >::type,
        -: 1312:          __tuple_like_ext<__libcpp_remove_reference_t<_Tuple1> >::value,
        -: 1313:          _Tuple1,
        -: 1314:          _Tuples...> {};
        -: 1315:
        -: 1316:template <class... _Tuples>
        -: 1317:struct __tuple_cat_return;
        -: 1318:
        -: 1319:template <class _Tuple0, class... _Tuples>
        -: 1320:struct __tuple_cat_return<_Tuple0, _Tuples...>
        -: 1321:    : public __tuple_cat_return_1<tuple<>,
        -: 1322:                                  __tuple_like_ext<__libcpp_remove_reference_t<_Tuple0> >::value,
        -: 1323:                                  _Tuple0,
        -: 1324:                                  _Tuples...> {};
        -: 1325:
        -: 1326:template <>
        -: 1327:struct __tuple_cat_return<> {
        -: 1328:  typedef _LIBCPP_NODEBUG tuple<> type;
        -: 1329:};
        -: 1330:
        -: 1331:inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 tuple<> tuple_cat() { return tuple<>(); }
        -: 1332:
        -: 1333:template <class _Rp, class _Indices, class _Tuple0, class... _Tuples>
        -: 1334:struct __tuple_cat_return_ref_imp;
        -: 1335:
        -: 1336:template <class... _Types, size_t... _I0, class _Tuple0>
        -: 1337:struct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>, _Tuple0> {
        -: 1338:  typedef _LIBCPP_NODEBUG __libcpp_remove_reference_t<_Tuple0> _T0;
        -: 1339:  typedef tuple<_Types..., __apply_cv_t<_Tuple0, typename tuple_element<_I0, _T0>::type>&&...> type;
        -: 1340:};
        -: 1341:
        -: 1342:template <class... _Types, size_t... _I0, class _Tuple0, class _Tuple1, class... _Tuples>
        -: 1343:struct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>, _Tuple0, _Tuple1, _Tuples...>
        -: 1344:    : public __tuple_cat_return_ref_imp<
        -: 1345:          tuple<_Types...,
        -: 1346:                __apply_cv_t<_Tuple0, typename tuple_element<_I0, __libcpp_remove_reference_t<_Tuple0>>::type>&&...>,
        -: 1347:          typename __make_tuple_indices<tuple_size<__libcpp_remove_reference_t<_Tuple1> >::value>::type,
        -: 1348:          _Tuple1,
        -: 1349:          _Tuples...> {};
        -: 1350:
        -: 1351:template <class _Tuple0, class... _Tuples>
        -: 1352:struct __tuple_cat_return_ref
        -: 1353:    : public __tuple_cat_return_ref_imp<
        -: 1354:          tuple<>,
        -: 1355:          typename __make_tuple_indices< tuple_size<__libcpp_remove_reference_t<_Tuple0> >::value >::type,
        -: 1356:          _Tuple0,
        -: 1357:          _Tuples...> {};
        -: 1358:
        -: 1359:template <class _Types, class _I0, class _J0>
        -: 1360:struct __tuple_cat;
        -: 1361:
        -: 1362:template <class... _Types, size_t... _I0, size_t... _J0>
        -: 1363:struct __tuple_cat<tuple<_Types...>, __tuple_indices<_I0...>, __tuple_indices<_J0...> > {
        -: 1364:  template <class _Tuple0>
        -: 1365:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1366:      typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&>::type
        -: 1367:      operator()(tuple<_Types...> __t, _Tuple0&& __t0) {
        -: 1368:    (void)__t; // avoid unused parameter warning on GCC when _I0 is empty
        -: 1369:    return std::forward_as_tuple(
        -: 1370:        std::forward<_Types>(std::get<_I0>(__t))..., std::get<_J0>(std::forward<_Tuple0>(__t0))...);
        -: 1371:  }
        -: 1372:
        -: 1373:  template <class _Tuple0, class _Tuple1, class... _Tuples>
        -: 1374:  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1375:      typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&, _Tuple1&&, _Tuples&&...>::type
        -: 1376:      operator()(tuple<_Types...> __t, _Tuple0&& __t0, _Tuple1&& __t1, _Tuples&&... __tpls) {
        -: 1377:    (void)__t; // avoid unused parameter warning on GCC when _I0 is empty
        -: 1378:    typedef _LIBCPP_NODEBUG __libcpp_remove_reference_t<_Tuple0> _T0;
        -: 1379:    typedef _LIBCPP_NODEBUG __libcpp_remove_reference_t<_Tuple1> _T1;
        -: 1380:    return __tuple_cat<tuple<_Types..., __apply_cv_t<_Tuple0, typename tuple_element<_J0, _T0>::type>&&...>,
        -: 1381:                       typename __make_tuple_indices<sizeof...(_Types) + tuple_size<_T0>::value>::type,
        -: 1382:                       typename __make_tuple_indices<tuple_size<_T1>::value>::type>()(
        -: 1383:        std::forward_as_tuple(
        -: 1384:            std::forward<_Types>(std::get<_I0>(__t))..., std::get<_J0>(std::forward<_Tuple0>(__t0))...),
        -: 1385:        std::forward<_Tuple1>(__t1),
        -: 1386:        std::forward<_Tuples>(__tpls)...);
        -: 1387:  }
        -: 1388:};
        -: 1389:
        -: 1390:template <class _Tuple0, class... _Tuples>
        -: 1391:inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 typename __tuple_cat_return<_Tuple0, _Tuples...>::type
        -: 1392:tuple_cat(_Tuple0&& __t0, _Tuples&&... __tpls) {
        -: 1393:  typedef _LIBCPP_NODEBUG __libcpp_remove_reference_t<_Tuple0> _T0;
        -: 1394:  return __tuple_cat<tuple<>, __tuple_indices<>, typename __make_tuple_indices<tuple_size<_T0>::value>::type>()(
        -: 1395:      tuple<>(), std::forward<_Tuple0>(__t0), std::forward<_Tuples>(__tpls)...);
        -: 1396:}
        -: 1397:
        -: 1398:template <class... _Tp, class _Alloc>
        -: 1399:struct _LIBCPP_TEMPLATE_VIS uses_allocator<tuple<_Tp...>, _Alloc> : true_type {};
        -: 1400:
        -: 1401:template <class _T1, class _T2>
        -: 1402:template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>
function _ZNSt3__14pairIKPvmEC1B8ne180100IJRS2_EJEJLm0EEJEEENS_21piecewise_construct_tERNS_5tupleIJDpT_EEERNS7_IJDpT0_EEENS_15__tuple_indicesIJXspT1_EEEENSG_IJXspT2_EEEE called 7 returned 100% blocks executed 100%
function _ZNSt3__14pairIKPvmEC2B8ne180100IJRS2_EJEJLm0EEJEEENS_21piecewise_construct_tERNS_5tupleIJDpT_EEERNS7_IJDpT0_EEENS_15__tuple_indicesIJXspT1_EEEENSG_IJXspT2_EEEE called 7 returned 100% blocks executed 100%
       14: 1403:inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 pair<_T1, _T2>::pair(
        -: 1404:    piecewise_construct_t,
        -: 1405:    tuple<_Args1...>& __first_args,
        -: 1406:    tuple<_Args2...>& __second_args,
        -: 1407:    __tuple_indices<_I1...>,
        -: 1408:    __tuple_indices<_I2...>)
        7: 1409:    : first(std::forward<_Args1>(std::get<_I1>(__first_args))...),
       14: 1410:      second(std::forward<_Args2>(std::get<_I2>(__second_args))...) {}
        7: 1410-block  0
        7: 1410-block  1
        -: 1411:
        -: 1412:#  if _LIBCPP_STD_VER >= 17
        -: 1413:template <class _Tp>
        -: 1414:inline constexpr size_t tuple_size_v = tuple_size<_Tp>::value;
        -: 1415:
        -: 1416:#    define _LIBCPP_NOEXCEPT_RETURN(...)                                                                               \
        -: 1417:      noexcept(noexcept(__VA_ARGS__)) { return __VA_ARGS__; }
        -: 1418:
        -: 1419:// The _LIBCPP_NOEXCEPT_RETURN macro breaks formatting.
        -: 1420:// clang-format off
        -: 1421:template <class _Fn, class _Tuple, size_t... _Id>
        -: 1422:inline _LIBCPP_HIDE_FROM_ABI constexpr decltype(auto)
        -: 1423:__apply_tuple_impl(_Fn&& __f, _Tuple&& __t, __tuple_indices<_Id...>)
        -: 1424:    _LIBCPP_NOEXCEPT_RETURN(std::__invoke(std::forward<_Fn>(__f), std::get<_Id>(std::forward<_Tuple>(__t))...))
        -: 1425:
        -: 1426:template <class _Fn, class _Tuple>
        -: 1427:inline _LIBCPP_HIDE_FROM_ABI constexpr decltype(auto) apply(_Fn&& __f, _Tuple&& __t)
        -: 1428:    _LIBCPP_NOEXCEPT_RETURN(std::__apply_tuple_impl(
        -: 1429:        std::forward<_Fn>(__f),
        -: 1430:        std::forward<_Tuple>(__t),
        -: 1431:        typename __make_tuple_indices<tuple_size_v<remove_reference_t<_Tuple>>>::type{}))
        -: 1432:
        -: 1433:template <class _Tp, class _Tuple, size_t... _Idx>
        -: 1434:inline _LIBCPP_HIDE_FROM_ABI constexpr _Tp __make_from_tuple_impl(_Tuple&& __t, __tuple_indices<_Idx...>)
        -: 1435:    _LIBCPP_NOEXCEPT_RETURN(_Tp(std::get<_Idx>(std::forward<_Tuple>(__t))...))
        -: 1436:
        -: 1437:template <class _Tp, class _Tuple>
        -: 1438:inline _LIBCPP_HIDE_FROM_ABI constexpr _Tp make_from_tuple(_Tuple&& __t)
        -: 1439:    _LIBCPP_NOEXCEPT_RETURN(std::__make_from_tuple_impl<_Tp>(
        -: 1440:        std::forward<_Tuple>(__t), typename __make_tuple_indices<tuple_size_v<remove_reference_t<_Tuple>>>::type{}))
        -: 1441:
        -: 1442:#    undef _LIBCPP_NOEXCEPT_RETURN
        -: 1443:
        -: 1444:#  endif // _LIBCPP_STD_VER >= 17
        -: 1445:
        -: 1446:#endif // !defined(_LIBCPP_CXX03_LANG)
        -: 1447:
        -: 1448:_LIBCPP_END_NAMESPACE_STD
        -: 1449:
        -: 1450:_LIBCPP_POP_MACROS
        -: 1451:
        -: 1452:// clang-format on
        -: 1453:
        -: 1454:#if !defined(_LIBCPP_REMOVE_TRANSITIVE_INCLUDES) && _LIBCPP_STD_VER <= 20
        -: 1455:#  include <exception>
        -: 1456:#  include <iosfwd>
        -: 1457:#  include <new>
        -: 1458:#  include <type_traits>
        -: 1459:#  include <typeinfo>
        -: 1460:#  include <utility>
        -: 1461:#endif
        -: 1462:
        -: 1463:#endif // _LIBCPP_TUPLE
